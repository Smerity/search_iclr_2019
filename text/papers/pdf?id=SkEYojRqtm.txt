Under review as a conference paper at ICLR 2019
REPRESENTATION DEGENERATION PROBLEM IN TRAINING NATURAL LANGUAGE GENERATION MOD-
ELS
Anonymous authors Paper under double-blind review
ABSTRACT
We study an interesting problem in training neural network-based models for natural language generation tasks, which we call the representation degeneration problem. We observe that when we train a model in natural language generation tasks through likelihood maximization with weight tying trick, especially with big training dataset, most of the learnt word embeddings tend to degenerate and be distributed into a narrow cone, which largely limits the representation power of word embeddings. We analyze the conditions and causes of this problem and propose a novel regularization method to address it. Experiments on language modeling and machine translation show that our method can largely mitigate the representation degeneration problem and achieve better performance than baseline algorithms.
1 INTRODUCTION
Neural network (NN)-based algorithms have made significant progresses in natural language generation tasks, including language modeling (Kim et al., 2016; Jozefowicz et al., 2016), machine translation (Wu et al., 2016; Britz et al., 2017; Vaswani et al., 2017; Gehring et al., 2017) and dialog systems (Shang et al., 2015). Despite the huge variety of applications and model architectures, natural language generation mostly relies on predicting the next word given previous contexts and other conditional information. A standard approach is to use a deep neural network to encode the inputs into a fixed-size vector referred to as hidden state,1 which is then multiplied by the word embedding matrix (Vaswani et al., 2017; Merity et al., 2017; Yang et al., 2017). The output logits are further consumed by the softmax function to give a categorical distribution of the next word. Then the model is trained through likelihood maximization.
While studying the learnt models for language generation tasks, we observe some interesting and surprising phenomena. As the word embedding matrix is tied with the softmax parameters (Vaswani et al., 2017; Merity et al., 2017; Yang et al., 2017; Inan et al., 2016), it has a dual role in the model, serving as the input in the first layer and the weights in the last layer. Given its first role as input word embedding, it should contain rich semantic information that captures the given context which will be further used for different tasks. Given its role as output softmax matrix, it should have enough capacity to classify different hidden states into correct labels. We compare it with word embeddings trained from Word2Vec (Mikolov et al., 2013) and the parameters in the softmax layer of a classical classification task (we refer it as categorical embedding). As shown in Figure 1, the word embeddings learnt from Word2Vec (Figure 1(b)) and the softmax parameters learnt from the classification task (Figure 1(c)) are diversely distributed around the origin using SVD projection, but the word embeddings in our studied model (Figure 1(a)) degenerated into a narrow cone. Furthermore, we find any two pairs of word embeddings in our studied models are positively correlated. Such phenomena are very different from those in other tasks and deteriorate model's capacity. As the role of the softmax layer, those parameters can not lead to a large margin prediction for good generalization. As the role of word embeddings, the parameters do not have enough capacity to model the diverse semantics in natural languages (Yang et al., 2017; McCann et al., 2017).
We call the problem described above the representation degeneration problem. In this paper, we try to understand why the problem happens and propose a practical solution to address it.
1The concept of hidden states has multiple meanings in the literature of neural networks. In this paper, we use hidden state as the input to the last softmax layer.
1

Under review as a conference paper at ICLR 2019

(a) Vanilla Transformer

(b) Word2Vec

(c) Classification

Figure 1: 2D visualization. (a). Visualization of word embeddings trained from vanilla Transformer (Vaswani et al., 2017) in EnglishGerman translation task. (b). Visualization of word embeddings trained from Word2Vec (Mikolov et al., 2013). (c). Visualization of hidden states and category embedding of a classification task, where different colors stand for different categories and the blue triangles denote for category embeddings.

We provide some intuitive explanation and theoretical justification for the problem. Intuitively speaking, during the training process of a model with likelihood loss, for any given hidden state, the embedding of the corresponding ground-truth word will be pushed towards the direction of the hidden state in order to get a larger likelihood, while the embeddings of all other words will be pushed towards the negative direction of the hidden state to get a smaller likelihood. As in natural language, word frequency is very low, the embedding of the word will be pushed towards the negative directions of most hidden states which drastically vary. As a result, the embeddings of most words in the vocabulary will be pushed towards similar directions negatively correlated with most hidden states and thus are clustered together in a local region of the embedding space.
From the theoretical perspective, we first analyze the extreme case of non-appeared words. We prove that the representation degeneration problem is related to the structure of hidden states: the degeneration appears when the convex hull of the hidden states does not contain the origin and such condition is likely to happen when training with layer normalization (Ba et al., 2016; Vaswani et al., 2017; Merity et al., 2017). We further extend our study to the optimization of low-frequency words in a more realistic setting. We show that, under mild conditions, the low-frequency words are likely to be trained to be close to each other during optimization, and thus lie in a local region.
Inspired by the empirical analysis and theoretical insights, we design a novel way to mitigate the degeneration problem by regularizing the word embedding matrix. As we observe that the word embeddings are restricted into a narrow cone, we try to directly increase the size of the aperture of the cone, which can be simply achieved by decreasing the similarity between individual word embeddings. We provide empirical study on the proposed method on two tasks, language modeling and machine translation. Experimental results show that the representation degeneration problem is mitigated, and our algorithm achieves superior performance over the baseline algorithms, e.g., with 2.0 point perplexity improvement on the WikiText-2 dataset for language modeling and 1.08/0.93 point BLEU improvement on WMT 2014 English-German/German-English tasks for machine translation.
2 RELATED WORK
Language modeling and machine translation are important language generation tasks. Language modeling aims at predicting the next token given an (incomplete) sequence of words as context. A popular approach based on neural networks is to map the given context to a real-valued vector as a hidden state, and then pass the hidden state through a softmax layer to generate a distribution over all the candidate words. There are different choices of neural networks used in language modeling. Recurrent neural network-based model and convolutional neural network-based model are widely used (Mikolov et al., 2010; Dauphin et al., 2017).
Neural machine translation (NMT) is a challenging task that has attracted lots of attention in recent years. Based on the encoder-decoder framework, NMT starts to show promising results in many language pairs. The evolving structures of NMT models in recent years have pushed the accuracy of NMT into a new level. The attention mechanism (Bahdanau et al., 2014) added on top of the
2

Under review as a conference paper at ICLR 2019
encoder-decoder framework is shown to be useful to automatically find alignment structure, and single-layer RNN-based structure has evolved towards deep models (Wu et al., 2016), more efficient CNN models (Gehring et al., 2017), and well-designed self-attention models (Vaswani et al., 2017).
In this paper, we mainly study the expressiveness of word embeddings in language generation tasks. A trend for language generation in recent years is to share the parameters between word embeddings and the softmax layer, which is named as the weight tying trick. Many state-of-the-art results in language modeling and machine translation are achieved with this trick (Vaswani et al., 2017; Merity et al., 2017; Yang et al., 2017). The paper (Inan et al., 2016) shows that weight tying not only reduces the number of parameters but also has theoretical benefits.
3 REPRESENTATION DEGENERATION PROBLEM
In this section, we empirically study the word embeddings learnt from sequence generation tasks, i.e., machine translation, and introduce the representation degeneration problem in neural sequence generation.
3.1 EXPERIMENTAL DESIGN
Our analysis reported in this section is mainly based on the state-of-the-art machine translation model Transformer (Vaswani et al., 2017). We use the official code (Vaswani et al., 2018) and set all the hyperparameters (the configurations of the base Transformer) as default. We train the model on the WMT 2014 English-German Dataset and achieve 27.3 in terms of BLEU score. Additionally, we also try it on LSTM-based model (Wu et al., 2016) and find the observations are similar.
In neural sequence generation tasks, the weights in word embeddings and softmax layer are tied. Those parameters can be recognized not only as the inputs in the first layer but also the weights in the last layer. Thus we compare this weight matrix with a word embedding matrix trained from conventional word representation learning task, and also compare it with the parameters in softmax layer of a conventional classification task. For simplicity and representative, we choose to use Word2Vec (Mikolov et al., 2013) to obtain word embeddings and use MNIST as the classification task trained with a two-layer convolutional neural network (Yue et al., 2018; Liu et al., 2016). For the classification task, We simply treat the row of the parameter matrix in the last softmax layer as the embedding for the category, like how the word embedding is used in the softmax layer for neural language generation model with weight tying trick.
To get a comprehensive understanding, we use low-rank approximation (rank = 2) for the learned matrices by SVD and plot them in a 2D plane, as shown in Figure 1. We also check the singular values distribution and find that our low-rank approximation is reasonable: other singular values are much smaller than the chosen ones.
3.2 DISCUSSION
In the classification task, the category embeddings (blue triangles in Figure 1(c)) in the softmax layer are diversely distributed around the origin. This shows the directions of category embeddings are different from each other and well separated, which consequently leads to large margin classification results with good generalization. For the word embeddings learnt from Word2Vec (Figure 1(b)), the phenomena are similar, the embeddings are also widely distributed around the origin in the projection space, which shows different words have different semantic meanings. Observations on GLOVE (Pennington et al., 2014) reported in Mu et al. (2017) are also consistent with ours.
We observe very different phenomena for machine translation. We can see from Figure 1(a) that the word embeddings are clustered together and only lying in a narrow cone. Furthermore, we find the cosine similarities between word embeddings are positive for almost all cases. That is, the words huddle together and are not well separated in the embedding space.
Clearly, as the role of word embeddings, which are the inputs to the neural networks, the word representations should be widely distributed to represent different semantic meanings. As the role of softmax in the output layer, to achieve good prediction of next word in a target sentence, a more diverse distribution of word embeddings in the space is expected to obtain a large margin result. However, such representations of words limit the expressiveness of the learnt model. We call such a problem the representation degeneration problem.
3

Under review as a conference paper at ICLR 2019

4 UNDERSTANDING THE PROBLEM

We show in the previous section that in training natural language generation models, the learnt word embeddings are clustered into a narrow cone and the model faces the challenge of limited expressiveness. In this section, we analyze the problem and show that it is related to the optimization of low-frequency words with diverse contexts.

In natural language generation tasks, the vocabulary is usually of large size and the words are of low frequencies according to Zipf's law. For example, more than 90% of words' frequencies are lower than 10e-6 in WMT 2014 English-German dataset. Note that even for a popular word, its frequency is also relatively low. For a concrete example, the frequency of the word "is" is only about 1% in the dataset, since "is" occurs at most once in most simple sentences. Our analysis is mainly based on the optimization pattern of the low-frequency words which occupy the major proportion of the vocabulary.

The generation of a sequence of words (or word indexes) y = (y1, · · · , yM ) is equivalent to generate the words one by one from left to right. The probability of generating y can be factorized as P (Y = y) = tP (Yt = yt|Y<t = y<t), where y<t denotes for the first t - 1 words in y. Sometimes, the generative model also depends on other context, e.g., the context from the source sentence for
machine translation. To study the optimization of the word embeddings, we simply consider the
generation of a word as a multi-class classification problem and formally describe the optimization
as follows.

Consider a multi-class classification problem with M samples. Let hi denote the hidden state before the softmax layer which can be also considered as the input features, i = 1, · · · , M . Without any

loss of generality, we assume hi is not a zero vector for all i. Let N denote the vocabulary size. The

conditional probability of yi  {1, · · · , N } is calculated by the softmax function: P (Yi = yi|hi) =

exp( hi,wyi )

N l=1

exp(

hi ,wl

,
)

where

wl

is

the

embedding

for

word/category

l,

l

=

1,

2,

·

··

,

N.

4.1 EXTREME CASE: NON-APPEARED WORD TOKENS

Note that in most NLP tasks, the frequencies of rare words are rather low, while the number of them is relatively large. With stochastic training paradigm, the probabilities to sample a certain infrequent word in a mini-batch are very low, and thus during optimization, the rare words behave similarly to a non-appeared word. We first consider the extreme case of non-appeared word in this section and extend to a more general and realistic scenario in the next section.

We assume yi = N for all i. That is, the N -th word with embedding wN does not appear in the corpus, which is the extreme case of a low-frequency rare word. We focus on the optimization
process of wN and assume all other parameters are fixed and well-optimized. By log-likelihood maximization, we have

1M max log wN M
i=1

exp( hi, wyi )

N l=1

exp(

hi, wl

. )

(1)

As

all

other

parameters

are

fixed,

this

is

equivalent

to

minwN

1 M

M i=1

log(exp(

hi, wN

) + Ci),

where Ci =

N -1 l=1

exp(

hi, wl

) and

can be considered as some constants.

Definition 1. We say that vector v is a uniformly negative direction of hi, i = 1, · · · , M , if v, hi <

0 for all i.

The following theorem provides a sufficient condition for the embedding wN approaching unbounded during optimization. We leave the proof of all the theorems in the appendix.
Theorem 1. A. If the set of uniformly negative direction is not empty, it is convex. B. If there exists a v that is a uniformly negative direction of hi, i = 1, · · · , M , then the optimal solution of (1) satisfies
wN =  and can be achieved by setting wN = limk+ k · v.
From the above theorem, we can see that if there exists a set of uniformly negative direction, the embedding wN can be optimized along any uniformly negative direction to infinity. As the set of uniformly negative direction is convex, wN is likely to lie in a convex cone and move to infinity during optimization. Next, we provide a sufficient and necessary condition for the existence of the uniformly negative direction.

4

Under review as a conference paper at ICLR 2019

Theorem 2. There exists a v that is a uniformly negative direction of a set of hidden states, if and only if the convex hull of the hidden states does not contain the origin.
Discussion on whether the condition happens in real practice From the theorem, we can see that the existence of the uniformly negative direction is highly related to the structure of the hidden states, and then affects the optimization of word embeddings. Note that a common trick used in sequence generation tasks is layer normalization (Ba et al., 2016; Vaswani et al., 2017; Merity et al., 2017), which first normalizes each hidden state vector into standard vector2, and then rescales/translates the standard vector with scaling/bias term. If the bias term is not a zero vector, it can be directly obtained that the space of hidden states doesn't contain the origin. As the bias term is a part of parameters to be optimized which can hardly be exactly zero, we have the assumption holds almost for sure in practice.

4.2 EXTENSION TO RARELY APPEARED WORD TOKENS

In the previous section, we show that under reasonable assumptions, the embeddings of all nonappeared word tokens will move together along the uniformly negative directions to infinity. However, it is not realistic that there exist non-appeared word tokens and the weights of embedding can be trained to be unbounded with L2 regularization term. In this section, we extend our analysis to the more realistic setting. The key we want to show is that the optimization of a rarely appeared word token is similar to that of non-appeared word tokens. Following the notations in the previous section, we denote the embedding of a rare word as wN and fix all other parameters. We study the optimization for this particular token with the negative log-likelihood loss function.

To clearly characterize the influence of wN to the loss function, we divide the loss function into

two pieces. Piece AwN contains the sentences that sentences are independently of wN and the ground

do not contain wN , truth label of each

i.e., all hidden

hidden states state (denoted

in such as wh)

is not wN . Then wN can be considered as a "non-appeared token" in this set. Denote the space

of the hidden state in piece AwN as HAwN with probability distribution PAwN , where HAwN and

PAwN can be continuous. The loss function on piece AwN can be defined as

LAwN (wN ) = -

log
HAwN

exp( h, wh )

N l=1

exp(

h, wl

) dPAwN (h),

(2)

which is a generalized version of Eqn. 1. Piece BwN contains the sentences which contain wN , i.e., wN appears in every sentence in piece BwN . Then in piece BwN , in some cases the hidden states are computed based on wN , e.g., when the hidden state is used to predict the next token after wN .
In some other cases, the hidden states are used to predict wN . Denote the space of the hidden state in piece BwN as HBwN with probability distribution PBwN . The loss function on piece BwN can be defined as

LBwN (wN ) = -

log
HBwN

exp( h, wh )

N l=1

exp(

h, wl

) dPBwn (h),

(3)

Based on these notations. the overall loss function is defined as

L(wN ) = P (sentence s in AwN )LAwN (wN ) + P (sentence s in BwN )LBwN (wN )

(4)

The loss on piece AwN is convex while the loss on piece BwN is complicated and usually non-
convex with respect to wN . The general idea is that given the fact that LAwN (wN ) is a convex
function with nice theoretical properties, if P (sentence s in AwN ) is large enough, e.g., larger than 1 - , and LBwN (wN ) is a bounded-smooth function. The optimal solution of L(wN ) is close to the
optimal solution of LAwN (wN ) which can be unique if LAwN (wN ) is strongly-convex. A formal description is as below.

Theorem 3. Given an -strongly convex function f (x) and a function g(x) that satisfies its Hessian

matrix H(g(x)) -I, where I is the identity matrix, and |g(x)| < B, for a given > 0, let x

and x be the optimum of f (x) and (1 - )f (x) + g(x), respectively. If

<

 +

,

x - x

2 2



4B - (+)

.

2the mean and variance of the values of the vector are normalized to be 0 and 1 respectively

5

Under review as a conference paper at ICLR 2019

Table 1: Experimental result on language modeling (perplexity). Bold numbers denote for the best result.

Model

Parameters Validation Test

2-layer skip connection LSTM (Mandt et al., 2017) (tied)

24M 69.1 65.9

AWD-LSTM (Merity et al., 2017) (w.o. finetune) AWD-LSTM (Merity et al., 2017) (w.t. finetune) AWD-LSTM (Merity et al., 2017) + continuous cache pointer

24M 24M 24M

69.1 66.0 68.6 65.8 53.8 52.0

MLE-CosReg (w.o. finetune) MLE-CosReg (w.t. finetune) MLE-CosReg + continuous cache pointer

24M 68.2 65.2 24M 67.1 64.1 24M 51.7 50.0

We make some further discussions regarding the theoretical results. In natural language generation,
for two low-frequency words w and w , piece Aw and Aw has large overlaps. Then the loss LAw (w) and LAw (w ) are similar with close optimum. According to the discussion above, the learnt word embedding of w and w is likely to be close to each other, which is also observed from the empirical
studies.

5 ADDRESSING THE PROBLEM

In this section, we propose an algorithm to address the representation degeneration problem. As shown in previous study, the learnt word embeddings are distributed in a narrow cone in the Euclid space which restricts the expressiveness of the representation. Then a straightforward approach is to improve the aperture of the cone which is defined as the maximum angle between any two boundaries of the cone. For the ease of optimization, we minimize the cosine similarities between any two word embeddings to increase the expressiveness.

For simplicity, we denote the normalized direction of w as w^, w^ =

w w

. Then our goal is to minimize

i j=i w^iT w^j as well as the original log-likelihood loss function. By introducing hyperparameter

 to trade off the log-likelihood loss and regularization term, the overall objective is,

L

=

1N LMLE +  N 2

N
w^iT w^j .

i j=i

(5)

We call this new loss as MLE with Cosine Regularization (MLE-CosReg). In the following, we make some analysis about the regularization term.

Denote R =

N i

N j=i

w^iT

w^j ,

and

denote

the

normalized

word

embedding

matrix

as

W^

=

[w^1, w^2, ..., w^N ]T . It is readily to check the regularizer has the matrix form as R =

N i

N j=i

w^iT

w^j

=

N i

N j

w^iT w^j

-

N i

w^ 2= Sum(W^ W^ T ) - N , where the Sum(·)

operator calculates the sum of all elements in the matrix. Since N is a constant, it suffices to con-

sider the first term Sum(W^ W^ T ) only.

Since W^ W^ T is a positive semi-definite matrix, all its eigenvalues are nonnegative. Since w^i is a normalized vector, every diagonal element of W^ W^ T is 1. Then the trace of W^ W^ T , which is also
the sum of the eigenvalues, equals to N .

As the cosine similarities between the word embeddings are all positive. According to Theorem 4, when W^ W^ T is a positive matrix, we have the largest absolute eigenvalue of W^ W^ T is upper bounded by Sum(W^ W^ T ). Then minimizing R is equivalent to minimize the upper bound of the largest eigenvalue. As the sum of all eigenvalues are constant, the side effect is to increase other eigenvalues, consequently improving the expressiveness of the embedding matrix.
Theorem 4. (Merikoski, 1984) For any matrix A, which is a real and nonnegative n × n matrix. The spectral radius, which is the largest absolute value of A's eigenvalues, is less than or equals to Sum(A).

6

Under review as a conference paper at ICLR 2019

Table 2: Experimental results on WMT English  German and German  English translation. Bold numbers denote for our results and  denotes for our implementation.

EnglishGerman

GermanEnglish

Model

BLEU Model

BLEU

ConvS2S (Gehring et al., 2017)

25.16 DSL (Xia et al., 2017b)

20.81

Base Transformer (Vaswani et al., 2017) 27.30 Dual-NMT (Xia et al., 2017a)

22.14

Base Transformer + MLE-CosReg

28.38 ConvS2S (Gehring et al., 2017)

29.61

Big Transformer (Vaswani et al., 2017) 28.40 Base Transformer (Vaswani et al., 2017) 31.00

Big Transformer + MLE-CosReg

28.94 Base Transformer + MLE-CosReg

31.93

6 EXPERIMENTS
We conduct experiments on two basic natural language generation tasks: language modeling and machine translation, and report the results in this section.
6.1 EXPERIMENTAL SETTINGS
6.1.1 LANGUAGE MODELING
Language modeling is one of the fundamental tasks in natural language processing. The goal is to predict the probability of the next word conditioned on previous words. The evaluation metric is perplexity. Smaller the perplexity, better the performance. We used WikiText-2 (WT2) corpus, which is popularly used in many previous works (Merity et al., 2016; Inan et al., 2016; Grave et al., 2016). WikiText-2 is sourced from curated Wikipedia articles and contains approximately a vocabulary of over 30,000 words. All the text has been tokenized and processed with the Moses tokenizer (Koehn et al., 2006). Capitalization, punctuation and numbers are retained in this dataset.
AWD-LSTM Merity et al. (2017) is the state-of-the-art model for language modeling. We directly followed the experimental settings as in Merity et al. (2017) to set up the model architecture and hyperparameter configurations. We used a three-layer LSTM with 1150 units in the hidden layer and set the size of embedding to be 400. The ratio for dropout connection on recurrent weight is kept the same as Merity et al. (2017). We trained the model with Averaged Stochastic Gradient Descent. Our implementation was based on open-sourced code3 by Merity et al. (2017). For our proposed MLE-CosReg loss, we found the hyperparameter  is not very sensitive and we set it to 1 in the experiments. We added neural cache model (Grave et al., 2016) to further reduce perplexity.
6.1.2 MACHINE TRANSLATION
Machine Translation aims at mapping sentences from a source domain to a target domain. We focus on English  German and German  English in our experiments. We used the dataset from standard WMT 2014, which consists of 4.5 million English-German sentence pairs and has been widely used as the benchmark for neural machine translation (Vaswani et al., 2017; Gehring et al., 2017). Sentences were encoded using byte-pair encoding (Sennrich et al., 2016), after which we got a shared source-target vocabulary with about 37000 subword units. We measured the performance with tokenized case-sensitive BLEU (Papineni et al., 2002).
We used state-of-the-art machine translation model Transformer (Vaswani et al., 2017), which utilizes self-attention mechanism for machine translation. We followed the setting in Vaswani et al. (2017) and used the official code (Vaswani et al., 2018) from Transformer. For both English  German and German  English tasks, we used the base version of Transformer (Vaswani et al., 2017), which has a 6-layer encoder and 6-layer decoder, the size of hidden nodes and embedding are set to 512. For English  German task, we additionally run an experiment on the big version of Transformer, which has 3x parameters compared with the base variant. All the models were trained with Adam optimizer, and all the hyper parameters were set as default as in Vaswani et al. (2017).  is set to 1 as in the experiments of language modeling.
3https://github.com/salesforce/awd-lstm-lm
7

Under review as a conference paper at ICLR 2019

(a) MLE-CosReg

(b) Singular Values

Figure 2: (a): Word embeddings trained from MLE-CosReg. (b): Singular values of embedding matrix. We normalize the singular values of each matrix so that the largest one is 1.

6.2 EXPERIMENTAL RESULTS
We present experimental results for language modeling in Table 1 and machine translation in Table 2.
For language modeling, we compare our method with vanilla AWD-LSTM (Merity et al., 2017) in three different settings, without finetune, with finetune and with further continuous cache pointer. Our method outperforms it with 0.8/1.7/2.0 improvements in terms of test perplexity. For machine translation, comparing with original base Transformer (Vaswani et al., 2017), our method improves performance with 1.08/0.93 for the English  German and German  English tasks, respectively, and achieves 0.54 improvement on the big Transformer.
Note that for all tasks, we only add one regularization term to the loss function, while no additional parameters or architecture/hyperparameters modifications are applied. Therefore, the accuracy improvements purely come from our proposed method. This demonstrates that by regularizing the similarity between word embeddings, our proposed MLE-CosReg loss leads to better performance.
6.3 DISCUSSION
The study above demonstrates the effectiveness of our proposed method in terms of final accuracy. However, it is still unclear whether our method has improved the representation power of learnt word embeddings. In this subsection, we provide a comprehensive study on the expressiveness of the model learnt by our algorithm.
For a fair comparison with the empirical study in Section 3, we analyze the word embeddings of our model on English  German translation task. We project the word embeddings into 2-dimensional space using SVD for visualization. Figure 2(a) shows that the learnt word embeddings are somewhat uniformly distributed around the origin and not strictly in a narrow cone like in Figure 1(a). This shows that our proposed regularization term effectively expands word embedding space. We also compare the singular values for word embedding matrix of our learnt model and the baseline model, as shown in the Figure 2(b). According to the figure, trained with vanilla Transformer, only a few singular values dominate among all singular values, while trained with our proposed method, the singular values distribute more uniformly. Again, this demonstrates the diversity of the word embeddings learnt by our method.
7 CONCLUSION AND FUTURE WORK
In this work, we described and analyzed the representation degeneration problem in training neural network models for natural language generation tasks both empirically and theoretically. We proposed a novel regularization method to increase the representation power of word embeddings explicitly. Experiments on language modeling and machine translation demonstrated the effectiveness of our method.
In the future, we will apply our method to more language generation tasks. Our proposed regularization term is based on cosine similarity. There may exist some better regularization terms. Furthermore, it is interesting to consider other approaches instead of regularization to enrich the representation of word embeddings.

8

Under review as a conference paper at ICLR 2019
REFERENCES
Jimmy Lei Ba, Jamie Ryan Kiros, and Geoffrey E Hinton. Layer normalization. arXiv preprint arXiv:1607.06450, 2016.
Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Bengio. Neural machine translation by jointly learning to align and translate. arXiv preprint arXiv:1409.0473, 2014.
Denny Britz, Anna Goldie, Thang Luong, and Quoc Le. Massive exploration of neural machine translation architectures. arXiv preprint arXiv:1703.03906, 2017.
Yann N Dauphin, Angela Fan, Michael Auli, and David Grangier. Language modeling with gated convolutional networks. In International Conference on Machine Learning, pp. 933­941, 2017.
Jonas Gehring, Michael Auli, David Grangier, Denis Yarats, and Yann N Dauphin. Convolutional sequence to sequence learning. In International Conference on Machine Learning, pp. 1243­ 1252, 2017.
Edouard Grave, Armand Joulin, and Nicolas Usunier. Improving neural language models with a continuous cache. arXiv preprint arXiv:1612.04426, 2016.
Hakan Inan, Khashayar Khosravi, and Richard Socher. Tying word vectors and word classifiers: A loss framework for language modeling. arXiv preprint arXiv:1611.01462, 2016.
Rafal Jozefowicz, Oriol Vinyals, Mike Schuster, Noam Shazeer, and Yonghui Wu. Exploring the limits of language modeling. arXiv preprint arXiv:1602.02410, 2016.
Yoon Kim, Yacine Jernite, David Sontag, and Alexander M Rush. Character-aware neural language models. In AAAI, pp. 2741­2749, 2016.
Philipp Koehn, Marcello Federico, Wade Shen, Nicola Bertoldi, Ondrej Bojar, Chris Callison-Burch, Brooke Cowan, Chris Dyer, Hieu Hoang, Richard Zens, et al. Open source toolkit for statistical machine translation: Factored translation models and confusion network decoding. In Final Report of the 2006 JHU Summer Workshop, 2006.
Weiyang Liu, Yandong Wen, Zhiding Yu, and Meng Yang. Large-margin softmax loss for convolutional neural networks. In ICML, pp. 507­516, 2016.
Stephan Mandt, Matthew D Hoffman, and David M Blei. Stochastic gradient descent as approximate bayesian inference. arXiv preprint arXiv:1704.04289, 2017.
Bryan McCann, James Bradbury, Caiming Xiong, and Richard Socher. Learned in translation: Contextualized word vectors. In Advances in Neural Information Processing Systems, pp. 6297­ 6308, 2017.
Jorma Kaarlo Merikoski. On the trace and the sum of elements of a matrix. Linear algebra and its applications, 60:177­185, 1984.
Stephen Merity, Caiming Xiong, James Bradbury, and Richard Socher. Pointer sentinel mixture models. arXiv preprint arXiv:1609.07843, 2016.
Stephen Merity, Nitish Shirish Keskar, and Richard Socher. Regularizing and optimizing lstm language models. arXiv preprint arXiv:1708.02182, 2017.
Toma´s Mikolov, Martin Karafia´t, Luka´s Burget, Jan C ernocky`, and Sanjeev Khudanpur. Recurrent neural network based language model. In Eleventh Annual Conference of the International Speech Communication Association, 2010.
Tomas Mikolov, Ilya Sutskever, Kai Chen, Greg S Corrado, and Jeff Dean. Distributed representations of words and phrases and their compositionality. In Advances in neural information processing systems, pp. 3111­3119, 2013.
Jiaqi Mu, Suma Bhat, and Pramod Viswanath. All-but-the-top: simple and effective postprocessing for word representations. arXiv preprint arXiv:1702.01417, 2017.
9

Under review as a conference paper at ICLR 2019
Kishore Papineni, Salim Roukos, Todd Ward, and Wei-Jing Zhu. Bleu: a method for automatic evaluation of machine translation. In Proceedings of the 40th annual meeting on association for computational linguistics, pp. 311­318. Association for Computational Linguistics, 2002.
Jeffrey Pennington, Richard Socher, and Christopher Manning. Glove: Global vectors for word representation. In Proceedings of the 2014 conference on empirical methods in natural language processing (EMNLP), pp. 1532­1543, 2014.
Rico Sennrich, Barry Haddow, and Alexandra Birch. Neural machine translation of rare words with subword units. In ACL, 2016.
Lifeng Shang, Zhengdong Lu, and Hang Li. Neural responding machine for short-text conversation. In Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing (Volume 1: Long Papers), volume 1, pp. 1577­1586, 2015.
Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez, Lukasz Kaiser, and Illia Polosukhin. Attention is all you need. In Advances in Neural Information Processing Systems, pp. 6000­6010, 2017.
Ashish Vaswani, Samy Bengio, Eugene Brevdo, Francois Chollet, Aidan N. Gomez, Stephan Gouws, Llion Jones, Lukasz Kaiser, Nal Kalchbrenner, Niki Parmar, Ryan Sepassi, Noam Shazeer, and Jakob Uszkoreit. Tensor2tensor for neural machine translation. CoRR, abs/1803.07416, 2018. URL http://arxiv.org/abs/1803.07416.
Yonghui Wu, Mike Schuster, Zhifeng Chen, Quoc V Le, Mohammad Norouzi, Wolfgang Macherey, Maxim Krikun, Yuan Cao, Qin Gao, Klaus Macherey, et al. Google's neural machine translation system: Bridging the gap between human and machine translation. arXiv preprint arXiv:1609.08144, 2016.
Yingce Xia, Jiang Bian, Tao Qin, Nenghai Yu, and Tie-Yan Liu. Dual inference for machine learning. In Proceedings of the Twenty-Sixth International Joint Conference on Artificial Intelligence (IJCAI), pp. 3112­3118, 2017a.
Yingce Xia, Tao Qin, Wei Chen, Jiang Bian, Nenghai Yu, and Tie-Yan Liu. Dual supervised learning. arXiv preprint arXiv:1707.00415, 2017b.
Zhilin Yang, Zihang Dai, Ruslan Salakhutdinov, and William W Cohen. Breaking the softmax bottleneck: a high-rank rnn language model. arXiv preprint arXiv:1711.03953, 2017.
Zhao Yue, Zhao Deli, Wan Shaohua, and Zhang Bo. Softmax supervision with isotropic normalization, 2018. URL https://openreview.net/forum?id=SyXNErg0W.
10

Under review as a conference paper at ICLR 2019

1 APPENDIX
In this section, we add proofs of all the theorems in the main sections. Theorem 1. A. If the set of uniformly negative direction is not empty, it is convex. B. If there exists a v that is a uniformly negative direction of hi, i = 1, · · · , M , then the optimal solution of (1) satisfies
wN =  and can be achieved by setting wN = limk+ k · v.

Proof. The first part is straight forward and we just prove the second part. De-

note v as any uniformly negative direction, and k as any positive value. We have

limk+

M i=1

log(exp(

hi, k

·

v

of the objective function in (3) and

)+ the

Ci) = objective

Mif=u1nclotigo(nCiis).coAnsvex,Mi=w1elohga(vCe iw) is

the lower bound = limk k · v

is local optimum and also the global optimum. Note that the lower bound can be achieved only if

hi, wN approaches negative infinity for all i. Then it is easy to check for any optimal solution wN = .

Theorem 2. There exists a v that is a uniformly negative direction of a set of hidden states, if and only if the convex hull of the hidden states does not contain the origin.

Proof. We first prove the necessary condition by contradiction. Suppose there are M hidden states

in the set. If the convex hull of hi, 1  i  M , contains the origin and there exists a uniformly

negative direction (e.g., v). Then from the definition of convex hull, there exists i, 1  i  M , such

that

M i

ihi

=

0,

i



0

and

i i = 1. Multiplying v on both sides, we have

i i hi, v = 0

,which contradicts with hi, v < 0 for all i.

For the sufficient part, if the convex hull of hi, 1  i  M , does not contain the origin, there exists at least one hyperplane H that passes through the origin and does not cross the convex hull. Then it is easy to check that a normal direction of the half space derived by the H is a uniformly negative direction. The theorem follows.

Theorem 3. Given an -strongly convex function f (x) and a function g(x) that satisfies its Hessian

matrix H(g(x)) -I, where I is the identity matrix, and |g(x)| < B, for a given > 0, let x

and x be the optimum of f (x) and (1 - )f (x) + g(x), respectively. If

<

 +

,

x - x

2 2



4B - (+)

.

Proof. We first prove the function (1 - )f (x) + g(x) is  - ( + )-strongly convex.
Let's consider the Hessian matrix of it. As f (x) is -strongly convex and H(g(x)) -I, using the definition of positive-definite matrix, the following inequality holds:

v, vT (H(g) + I)v > 0; vT (H(f ) - I)v > 0.

(6) (7)

we omit x here, without loss of clearity. Then for the Hessian matrix of (1 - )f (x) + g(x), we have:

v, vT (H((1 - )f + g) - ( - ( + ))I)v = vT (H((1 - )f ) + H( g) - (1 - )I + I)v = vT ((1 - )H(f ) + H(g) - (1 - )I + I)v = vT ((1 - )(H(f ) - I) + (H(g) + I))v = vT ((1 - )(H(f ) - I))v + vT ( (H(g) + I))v = (1 - )vT (H(f ) - I)v + vT (H(g) + I)v > (1 - )0 + 0 = 0.

(8) (9) (10) (11) (12) (13) (14) (15)

11

Under review as a conference paper at ICLR 2019

Thus, H((1- )f (x)+ g(x))-(- (+))I is positive-definite, which means (1- )f (x)+ g(x) is  - ( + )-strongly convex. Then, with the properties in strong convexity, we have:

x - x

2 2



-

2 (f (x) + ( + )

g(x) - f (x) -

g(x))



-

2 ( g(x) - ( + )

g(x))



4B  - ( + )

(16) (17) (18)

12

