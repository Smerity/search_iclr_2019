Under review as a conference paper at ICLR 2019
DEEP FRANK-WOLFE FOR NEURAL NETWORK OPTIMIZATION
Anonymous authors Paper under double-blind review
ABSTRACT
Learning a deep neural network requires solving a challenging optimization problem: it is a high-dimensional, non-convex and non-smooth minimization problem with a large number of terms. The current practice in neural network optimization is to rely on the stochastic gradient descent (SGD) algorithm or its adaptive variants. However, SGD requires a hand-designed schedule for the learning rate. In addition, its adaptive variants tend to produce solutions that generalize less well on unseen data than SGD with a hand-designed schedule. We present an optimization method that offers the best of both worlds: our algorithm yields good generalization performance while requiring only one hyper-parameter. Our approach is based on a composite proximal framework, which exploits the compositional nature of deep neural networks and can leverage powerful convex optimization algorithms by design. Specifically, we employ the Frank-Wolfe (FW) algorithm for SVM, which computes an optimal step-size in closed-form at each time-step. We further show that the descent direction is given by a simple backward pass in the network, yielding the same computational cost per iteration as SGD. We customize the algorithm in two ways to further improve its performance. First, we use a descent direction that smoothes the loss function to better condition the problem. Second, we combine our proximal algorithm with Nesterov momentum to benefit from acceleration. We present experiments on the CIFAR and SNLI data sets, where we demonstrate the significant superiority of our method over Adam, Adagrad, as well as the recently proposed BPGrad and AMSGrad. Furthermore, we compare our algorithm to SGD with a hand-designed learning rate schedule, and show that it provides similar generalization while converging faster.
1 INTRODUCTION
Since the introduction of back-propagation (Rumelhart et al., 1986), stochastic gradient descent (SGD) has been the most commonly used optimization algorithm for deep neural networks. While yielding remarkable performance on a variety of learning tasks, a downside of the SGD algorithm is that it requires a schedule for the decay of its learning rate. In the convex setting, curvature properties of the objective function can be used to design schedules that are hyper-parameter free and guaranteed to converge to the optimal solution (Bubeck, 2015). However, there is no analogous result of practical interest for the non-convex optimization problem of a deep neural network. An illustration of this issue is the diversity of learning rate schedules used to train deep convolutional networks with SGD: Simonyan & Zisserman (2015) and He et al. (2016) adapt the learning rate according to the validation performance, while Szegedy et al. (2015), Huang et al. (2017) and Loshchilov & Hutter (2017) use pre-determined schedules, which are respectively piecewise constant, geometrically decaying, and cyclic with a cosine annealing. While these protocols result in competitive or state-of-the-art results on their learning task, there does not seem to be a consistent methodology. As a result, finding such a schedule for a new setting is a time-consuming and computationally expensive effort. To alleviate this issue, adaptive gradient methods have been developed (Zeiler, 2012, Kingma & Ba, 2015, Reddi et al., 2018), and borrowed from online convex optimization (Duchi et al., 2011). Typically, these methods only require the tuning of the initial learning rate, the other hyper-parameters being considered robust across applications. However, it has been shown that such adaptive gradient methods obtain worse generalization than SGD (Wilson et al., 2017). This observation is corroborated by our experimental results.
1

Under review as a conference paper at ICLR 2019
In order to bridge this performance gap between existing adaptive methods and SGD, we introduce a new optimization algorithm, called Deep Frank-Wolfe (DFW). The DFW algorithm exploits the composite structure of deep neural networks to design an optimization algorithm that leverages efficient convex solvers. In more detail, we consider a composite (nested) optimization problem, with the loss as the outer function and the function encoded by the neural network as the inner one. At each iteration, we define a proximal problem with a first-order approximation of the neural network (linearized inner function), while keeps the loss function in its exact form (exact outer function). When the loss is the hinge loss, each proximal problem created by our formulation is exactly a linear SVM. This allows us to employ the powerful FW algorithm as the workhorse of our procedure. There are two by-design advantages to our method compared to the SGD algorithm. First, each iteration exploits more information about the learning objective, while preserving the same computational cost. Second, an optimal step-size is computed in closed-form by using the Frank-Wolfe (FW) algorithm in the dual (Frank & Wolfe, 1956, Lacoste-Julien et al., 2013). Consequently, we do not need a hand-designed schedule for the learning rate. As a result, our algorithm is the first to provide competitive generalization error compared to SGD, all the while requiring a single hyper-parameter and often converging significantly faster. We present two additional improvements to customize the use of the DFW algorithm to deep neural networks. First, we show how to smooth the loss function to avoid optimization difficulties arising from learning deep models with SVMs (Berrada et al., 2018). Second, we incorporate Nesterov momentum (Nesterov, 1983) to accelerate our algorithm. We demonstrate the efficacy of our method on image classification with wide residual networks (Zagoruyko & Komodakis, 2016) and densely connected convolutional neural networks (Huang et al., 2017) on the CIFAR data sets (Krizhevsky, 2009), and on natural language inference with a Bi-LSTM on the SNLI corpus (Bowman et al., 2015). We show that the DFW algorithm often strongly outperforms previous methods based on adaptive learning rates. Furthermore, it provides comparable or better accuracy to SGD with hand-designed learning rate schedules. In conclusion, our contributions can be summed up as follows:
· We propose a proximal framework which preserves information from the loss function. · For the first time for deep neural networks, we demonstrate how our formulation gives
at each iteration (i) an optimal step-size in closed form and (ii) an update at the same computational cost as SGD. · We design a novel smoothing scheme for the dual optimization of SVMs and we customize Nesterov momentum to accelerate our algorithm. · To the best of our knowledge, the resulting DFW algorithm is the first to offer comparable or better generalization to SGD with a hand-designed schedule on the CIFAR data sets, all the while converging several times faster and requiring only a single hyperparameter.
2 RELATED WORK
Non Gradient-Based Methods. The success of a simple first-order method such as SGD has led to research in other more sophisticated techniques based on relaxations (Heinemann et al., 2016, Zhang et al., 2017a), learning theory (Goel et al., 2017), Bregman iterations (Taylor et al., 2016), and even second-order methods (Roux et al., 2008, Martens & Sutskever, 2012, Ollivier, 2013, Desjardins et al., 2015, Martens & Grosse, 2015, Grosse & Martens, 2016, Ba et al., 2017, Botev et al., 2017, Martens et al., 2018). While such methods hold a lot of promise, their relatively large per-iteration cost limits their scalability in practice. As a result, gradient-based methods continue to be the most popular optimization algorithms for learning deep neural networks. Adaptive Gradient Methods. As mentioned earlier, one of the main challenges of using SGD is the design of a learning rate schedule. Several works proposed alternative first-order methods that do not require such a schedule, by either modifying the descent direction or adaptively rescaling the step-size (Duchi et al., 2011, Zeiler, 2012, Schaul et al., 2013, Kingma & Ba, 2015, Zhang et al., 2017b, Reddi et al., 2018). However, as mentioned earlier, the adaptive variants of SGD sometimes provide subpar generalization (Wilson et al., 2017).
2

Under review as a conference paper at ICLR 2019

Learning to Learn and Meta-Learning. Learning to learn approaches have also been proposed to optimize deep neural networks. Baydin et al. (2018) and Wu et al. (2018) learn the learning rate to avoid a hand-designed schedule and to improve practical performance. Such methods can be combined with our proposed algorithm to learn its proximal coefficient, instead of considering it as a fixed hyper-parameter to be tuned. Meta-learning approaches have also been suggested to learn the optimization algorithm (Andrychowicz et al., 2016, Ravi & Larochelle, 2017, Wichrowska et al., 2017, Li & Malik, 2017). This line of work, which is orthogonal to ours, could benefit from the use of DFW to optimize the meta-learner. Optimization and Generalization. Several works study the relationship between optimization and generalization in deep learning. In order to promote generalization within the optimization algorithm itself, Neyshabur et al. (2015; 2016) proposed the Path-SGD algorithm, which implicitly controls the capacity of the model. However, their method required the model to employ ReLU non-linearity only, which is an important restriction for practical purposes. Hardt et al. (2016), Arpit et al. (2017), Neyshabur et al. (2017), Hoffer et al. (2017) and Chaudhari & Soatto (2018) analyzed how existing optimization algorithms implicitly regularize deep neural networks. However this phenomenon is not yet fully understood, and the resulting empirical recommendations are sometimes opposing (Hardt et al., 2016, Hoffer et al., 2017). Proximal Methods. The back-propagation algorithm has been analyzed in a proximal framework in (Frerix et al., 2018). Yet, the resulting approach still requires the same hyper-parameters as SGD and incurs a higher computational cost per iteration. Linear SVM Sub-Problems. A main component of our formulation is to formulate sub-problems as linear SVMs. Berrada et al. (2017) showed that neural networks with piecewise linear activations could be trained with the CCCP algorithm (Yuille & Rangarajan, 2002), which yielded approximate SVM problems to be solved with the BCFW algorithm (Lacoste-Julien et al., 2013). However their algorithm only updates the parameters of one layer at a time, which slows down convergence considerably in practice. Closest to our approach are the works of (Hochreiter & Obermayer, 2005) and (Singh & Shawe-Taylor, 2018). Hochreiter & Obermayer (2005) suggested to create a local SVM based on a first-order Taylor expansion and a proximal term, in order to lower the error of every data sample while minimizing the changes in the weights. However their method operated in a nonstochastic setting, making the approach infeasible for large-scale data sets. Singh & Shawe-Taylor (2018), a parallel work to ours, also created an SVM problem using a first-order Taylor expansion, this time in a mini-batch setting. Their work provided interesting insights from a statistical learning theory perspective. While their method is well-grounded, its significantly higher cost per iteration impairs its practical speed and scalability. As such, it can be seen as complementary to our empirical work, which exploits a powerful solver and provides state-of-the-art scalability and performance.

3 PROBLEM FORMULATION

Before describing our formulation, we introduce some necessary notation. We use · to denote

the Euclidean norm. Given a function , (u) at u^. According to the situation, this derivative

cu^anis

the derivative be a gradient,

of  with respect to u evaluated a Jacobian or even a directional

derivative. Its exact nature will be clear from context throughout the paper. We also introduce the

first-order Taylor a positive integer

expansion of p, we denote

 around the point the set {1, 2, ..., p}

au^s:[pT]u^.F(our)si=mpl(iuc^i)ty+, w(ea(susu)mu^e)

(u that

- u^). For stochastic

algorithms process only one sample at each iteration, although the methods can be trivially extended

to mini-batches of size larger than one.

3.1 LEARNING OBJECTIVE We suppose we are given a data set (xi, yi)i[N], where each xi  Rd is a sample annotated with a label yi from the output space Y. The data set is used to estimate a parameterized model represented by the function f . Given its (flattened) parameters w  Rp, and an input xi  Rd, the model predicts f (w, xi)  R|Y|, a vector with one score per element of the output space Y. For instance, f can be a linear map or a deep neural network.

3

Under review as a conference paper at ICLR 2019

Given a vector of scores per label s  R|Y|, we denote by L(s, yi) the loss function that computes the risk of the prediction scores s given the ground truth label yi. For example, the loss L can be cross-entropy or the multi-class hinge loss:

(Cross-Entropy Loss) LCE : (s, y)  R|Y| × Y  log

exp(sk) - sy,

kY

(1)

(Multi-Class Hinge Loss) Lhinge : (s, y)  R|Y|×Y  max max {sk + 1 - sy} , 0 . (2)
kY \{y}

The cross-entropy loss (1) tries to match the empirical distribution by driving incorrect scores as

far as possible from the ground truth one. The hinge loss (2) attempts to create a minimal margin

of one between correct and incorrect scores. The hinge loss has been shown to be more robust to

over-fitting than cross-entropy, when combined with smoothing techniques that are common in the

optimization literature (Berrada et al., 2018). To simplify notation, we introduce fi(w) = f (w, xi) and Li(s) = L(s, yi) for each i  [N ]. Finally, we denote by (w) the regularization (typically the squared Euclidean norm). We now write the learning problem under its empirical risk minimization

form:

min (w) + 1

wRp

N

Li(fi(w)).

i[N ]

(3)

3.2 A PROXIMAL APPROACH Our main contribution is a formulation which exploits the composite nature of deep neural networks in order to obtain a better approximation of the objective at each iteration. Thanks to the careful approximation design, this approach yields sub-problems that are amenable to efficient optimization by powerful convex solvers. In order to understand the intuition of our approach, we first present a proximal gradient perspective on SGD.

The SGD Algorithm. At iteration t, the SGD algorithm selects a sample j at random and observes the objective estimate (wt) + Lj(fj(wt)). Then, given the learning rate t, it performs the following update on the parameters:

wt+1 = wt - t (w) wt + Lj (fj (w)) wt .

(4)

Equation (4) is the closed-form solution of a proximal problem where the objective has been linearized

by the first-order Taylor expansion Twt (Bubeck, 2015):

wt+1 = arg min
wRp

1 2t

w - wt

2 + Twt (w) + Twt [Lj (fj (w))]

.

(5)

To see the relationship between (4) and (5), one can set the gradient with respect to w to 0 in equation

(5), and observe that the resulting equation is exactly (4). In other words, SGD minimizes a first-order

approximation of the objective, while encouraging proximity to the current estimate wt.

However, one can also choose to linearize only a part of the composite objective (Lewis & Wright, 2016). Choosing which part to approximate is a crucial decision, because it yields optimization problems with widely different properties. In this work, we suggest an approach that lends itself to fast optimization with robust convex solvers and preserves information about the learning task by keeping an exact loss function.

Loss-Preserving Linearization. In detail, at iteration t, with selected sample j, we introduce the proximal problem that linearizes the regularization  and the model fj, but not the loss function L:

min
wRp

1 2t

w - wt

2 + Twt (w) + Lj (Twt fj (w))

.

(6)

In figure 1, we provide a visual comparison of equations (5) and (6) in the case of a piecewise linear loss. As will be seen, by preserving the loss function, we will be able to achieve good performance across a number of tasks with a fixed t = . Consequently, we will provide the first algorithm to accurately learn deep neural networks with only a single hyper-parameter while offering similar performance compared to SGD with a hand-designed schedule.

4

Under review as a conference paper at ICLR 2019

Original Objective  Linearization (SGD) Loss-Preserving Linearization (LPL)

Original Objective  Proximal Objective (SGD, eq. (5)) Proximal Objective (LPL, eq. (6))

(w)

(w)

wt w

wt

wtL+P1L w

wtS+G1D

Figure 1: We illustrate the different approximations on a synthetic composite objective function

(w) = L(f (w)) ( is plotted in black). In this example, L is a maximum of linear functions

(similarly to a hinge loss) and f is a non-linear smooth map. We denote the current iterate by wt, and the point minimizing  by w. On the left-hand side, one can observe how the SGD approximation is a single line (tangent at (wt), in blue), while the LPL approximation is piecewise linear (in orange), and thus matches the objective curve (in black) more closely. On the right-hand side, an identical

proximal term is added to both approximations to visualize equations (5) and (6). Thanks to the

better accuracy of the LPL approximation, the iterate wtL+PL1 gets closer to the solution w than wtS+GD1 .

This effect is particularly learning rate t is large.

true when the proximal Indeed, the accuracy of

tchoeelffiocciaelnatp2p1rtoixsimsmataiolln,

or equivalently, when the becomes more important

when the proximal term is contributing less (e.g. when t is large).

4 THE DEEP FRANK-WOLFE ALGORITHM

4.1 ALGORITHM

We focus on the optimization of equation (6) when L is a multi-class hinge loss (2). The results of this section were originally derived for linear models (Lacoste-Julien et al., 2013). Our contribution is to show for the first time how they can be exploited for deep neural networks thanks to our formulation (6). We will refer to the resulting algorithm for neural networks as Deep Frank-Wolfe (DFW). We begin by stating the key advantage of our method. Proposition 1 (Optimal step-size, (Lacoste-Julien et al., 2013)). Problem (6) with a hinge loss is amenable to optimization with Frank-Wolfe in the dual, which yields an optimal step-size t  [0, 1] in closed-form at each iteration t.

This optimal step-size can be obtained in closed-form because the hinge loss is convex and piecewise linear. In fact, the approach presented here can be applied to any loss function L that is convex and piecewise linear (another example would be the l1 distance for regression for instance).

Since the step-size can be computed in closed-form, the main computational challenge is to obtain the update direction, that is, the conditional gradient of the dual. In the following result, we show that by taking a single step per proximal problem, this dual conditional gradient can be computed at the same cost as a standard stochastic gradient. The proof is available in appendix A.5.

Proposition 2 (Cost per iteration). If a single step is performed on the dual of (6), its conditional

gradient is given by - ((w) + Ly(fx(w))) be written as:

.
wt

Given the step-size t, the resulting update can

wt+1 = wt -  (w) wt + tLj (fj (w)) wt

(7)

In other words, the cost per iteration of the DFW algorithm is the same as SGD, since the update only requires standard stochastic gradients. Therefore DFW can be effectively applied to deep neural networks at the same cost per iteration as SGD.

One can observe how the update (7) exploits the optimal step-size t  [0, 1] given by Proposition

1. There is a geometric interpretation to the role of this step-size t. When t is set to its minimal

value 0, the resulting iterate does optimal, this can only happen if

not the

cmuorrveenatliotenrgatteheisddireetcetciotendtLo jb(efja(twa)m) iwnitm. Suimncoefththeespteipe-cseiwzeisies

5

Under review as a conference paper at ICLR 2019

linear approximation. Conversely, when t reaches its maximal value 1, the algorithm tries to move

as far as obtained

possible by SGD

along the (as given

direction Lj(fj by equation (4)).

(Iwn o))thwert

. In that case, words, t can

the update is the same as the one automatically decay the effective

learning rate, hereby preventing the need to design a learning rate schedule by hand.

As mentioned previously, the DFW algorithm performs only one step per proximal problem. Since problem (6) is only an approximation of the original problem (3), it may be unnecessarily expensive to solve it very accurately. Therefore taking a single step per proximal problem may help the DFW algorithm to converge faster. This is confirmed by our experimental results, which show that DFW is often able to minimize the learning objective (3) at greater speed than SGD.

4.2 IMPROVEMENTS FOR DEEP NEURAL NETWORKS We present two improvements to customize the application of our algorithm to deep neural networks.

Smoothing. The SVM loss is non-smooth and has sparse derivatives, which can cause difficulties when training a deep neural network (Berrada et al., 2018). In Appendix A.6, we derive a novel result that shows how we can exploit the smooth primal cross-entropy direction and inexpensively detect when to switch back to using the standard conditional gradient.

Nesterov Momentum. To take advantage of acceleration similarly to the SGD baseline, we adapt the Nesterov momentum to the DFW algorithm. We defer the details to the appendix in A.7 for space reasons. We further note that the momentum coefficient µ is typically set to a high value, say 0.9, and does not contribute significantly to the computational cost of cross-validation.

4.3 ALGORITHM SUMMARY The main steps of DFW are shown in Algorithm 1. As the key feature of our approach, note that the step-size is computed in closed-form in step 10 of the algorithm (colored in blue).

Algorithm 1 The Deep Frank-Wolfe Algorithm

Require: proximal coefficient , initial point w0  Rp, momentum coefficient µ, number of epochs

1: t = 0

2: z0 = 0 3: for each epoch do

Momentum velocity (initialization) Iteration over epochs

4: for i=1..N do

Iteration over samples or mini-batches (usually in random order)

5: Receive sample (xi, yi)

6: bt(wt) = (fxi,y¯(wt) - fxi,yi (wt) + (y¯, yi))y¯Y

Augmented scores

7: 8:

rt = (w) wt st  dual_direction()

Derivative of regularization (Smoothed) dual direction (details in Appendix A.6)

9: t =  st bt(w) wt

Derivative of (smoothed) loss function

10: 11:

t = zt+1

(-t = µzt

rt -

+ts(trtb+t(wtt)))/(

t

2) clipped to [0, 1]

Step-size Velocity accumulation

12: wt+1 = wt -  [rt + tt] + µzt+1

Parameters update

13: t = t + 1

14: end for

15: end for

Note that only the hyper-parameter  will be tuned in our experiments: we will use the same batchsize, momentum and number of epochs as the baselines in our experiments. In addition, we point out again that when t = 1, we recover the SGD step with Nesterov momentum. In sections A.5 and A.6 of the appendix, we detail the derivation of the optimal step-size (step 10) and the computation of the search direction (step 8). The computation of the dual search direction is omitted here for space reasons. However, its implementation is straightforward in practice, and its computational cost is linear in the size of the output space.

6

Under review as a conference paper at ICLR 2019
Finally, we emphasize that the DFW algorithm is motivated by an empirical perspective. While our method is not guaranteed to converge, our experiments show an effective minimization of the learning objective for the problems encountered in practice.
5 EXPERIMENTS
We compare the Deep Frank Wolfe (DFW) algorithm to the state-of-the-art optimizers. We show that, across diverse data sets and architectures, the DFW algorithm outperforms adaptive gradient methods (with the exception of one setting, DN-10, where it obtains similar performance to AMSGrad and BPGrad). In addition, the DFW algorithm offers competitive and sometimes superior performance to SGD at considerably less computational cost, even though SGD has the advantage of a hand-designed schedule that has been hand-designed separately for each of these tasks. Our experiments are implemented in pytorch (Paszke et al., 2017), and the code will be made publicly available. All models are trained on a single Nvidia Titan Xp card. 5.1 IMAGE CLASSIFICATION WITH CONVOLUTIONAL NEURAL NETWORKS Data Set & Architectures. The CIFAR-10/100 data sets contain 60,000 RGB natural images of size 32 × 32 with 10/100 classes (Krizhevsky, 2009). We split the training set into 45,000 training samples and 5,000 validation samples, and use 10,000 samples for testing. The images are centered and normalized per channel. As is standard practice, we use random horizontal flipping and random crops with four pixels padding. We perform our experiments on two modern architectures of deep convolutional neural networks: wide residual networks (Zagoruyko & Komodakis, 2016), and densely connected convolutional networks (Huang et al., 2017). Specifically, we employ a wide residual network of depth 40 and width factor 4, which has 8.9M parameters, and a "bottleneck" densely connected convolutional neural network of depth 40 and growth factor 40, which has 1.9M parameters. We refer to these architectures as WRN and DN respectively. All the following experimental details follow the protocol of (Zagoruyko & Komodakis, 2016) and (Huang et al., 2017). The only difference is that, instead of using 50,000 samples for training, we use 45,000 samples for training, and 5,000 samples for the validation set, which we found to be essential for all adaptive methods. While Deep Frank Wolfe (DFW) uses an SVM loss, the baselines are trained with the Cross-Entropy (CE) loss since this resulted in better performance. Method. We compare DFW to the most common adaptive learning rates currently used: Adagrad (Duchi et al., 2011), Adam (Kingma & Ba, 2015), the corrected version of Adam called AMSGrad (Reddi et al., 2018), and BPGrad (Zhang et al., 2017b). For these methods and for DFW, we cross-validate the initial learning rate as a power of 10. We also evaluate the performance of SGD with momentum (simply referred to as SGD), for which we follow the protocol of (Zagoruyko & Komodakis, 2016) and (Huang et al., 2017). For all methods, we set a budget of 200 epochs for WRN and 300 epochs for DN. For DN, the l2 regularization is set to 10-4 as in (Huang et al., 2017). For WRN, the l2 is cross-validated between 5.10-4, as in (Zagoruyko & Komodakis, 2016), and 10-4, a more usual value that we have found to perform better for some of the methods (in particular DFW, since the corresponding loss function is an SVM instead of CE, for which the value of 5.10-4 was designed). The value of the Nesterov momentum is set to 0.9 for BPGrad, SGD and DFW. DFW has only one hyper-parameter to tune, namely , which is analogous to an initial learning rate. For SGD, the initial learning rate is set to 0.1 on both WRN and DN. Following (Zagoruyko & Komodakis, 2016) and (Huang et al., 2017), it is then divided by 5 at epochs 60, 120 and 180 for WRN, and by 10 at epochs 150 and 225 for DN. Results. We present the results in Tables 1 and 2. Observe that DFW significantly outperforms the adaptive gradient methods, particularly on the more challenging CIFAR-100 data set. On the WRN-CIFAR-100 task in particular, DFW obtains a testing accuracy which is about 7% higher than all other adaptive methods and outperforms SGD with a hand-designed schedule by 1%. The inferior generalization of adaptive gradient methods is consistent with the findings of Wilson et al. (2017). On all tasks, the accuracy of DFW is comparable to SGD. Note that DFW converges significantly faster than SGD: the network reaches its final performance several times faster than SGD in all cases. We illustrate this with an example in figure 2, which plots the training and validation errors on
7

Under review as a conference paper at ICLR 2019

Architecture
WRN WRN WRN WRN WRN WRN DN DN DN DN DN DN

Optimizer
Adagrad Adam AMSGrad BPGrad DFW SGD Adagrad Adam AMSGrad BPGrad DFW SGD

Test Accuracy (%)
86.07 84.86 86.08 88.62 90.18 90.08 87.32 88.44 90.53 90.85 90.22
92.02

Table 1: Results on CIFAR-10. DFW outperforms Adam by 5% on WRN and 2% on DN. All adaptive methods only have one hyperparameter.

Architecture
WRN WRN WRN WRN WRN WRN DN DN DN DN DN DN

Optimizer
Adagrad Adam AMSGrad BPGrad DFW SGD Adagrad Adam AMSGrad BPGrad DFW SGD

Test Accuracy (%)
57.64 58.46 60.73 60.31 67.83 66.78 56.47 64.61 68.32 59.36 69.55
70.33

Table 2: Results on CIFAR-100. DFW outperforms all baselines by 7% on the WRN architecture. In addition it exceeds the accuracy of Adagrad by 14% on the DN architecture.

DN-CIFAR-100. In figure 3, one can see how the step-size is automatically decayed by DFW on this same experiment: we compare the effective learning rate t for DFW to the hand-designed learning rate t for SGD.

Error (%) Step-Size

80 train-SGD
train-DFW
60 validation-SGD
validation-DFW
40
20
0 012345 Time (hr)
Figure 2: Training and validation error during the training of DN on CIFAR-100. DFW converges significantly faster than SGD.

10-1 10-2

SGD DFW

10-3
012345 Time (hr)
Figure 3: The (automatic) evolution of t for the DFW algorithm compared to the "staircase" hand-designed schedule of t for SGD.

5.2 NATURAL LANGUAGE INFERENCE WITH RECURRENT NEURAL NETWORKS Data Set. The Stanford Natural Language Inference (SNLI) data set is a large corpus of 570k pairs of sentences (Bowman et al., 2015). Each sentence is labeled by one of the three possible labels: entailment, neutral and contradiction. This allows the model to learn the semantics of the text data from a three-way classification problem. Thanks to its scale and its supervised labels, this data set allows large neural networks to learn high-quality text embeddings. As Conneau et al. (2017) demonstrate, the SNLI corpus can thus be used as a basis for transfer learning in natural language processing, in the same way that the ImageNet data set is used for pre-training in computer vision. Method. We follow the protocol of (Conneau et al., 2017) to learn their best model, namely a bi-directional LSTM of about 47M parameters. In particular, the reported results use SGD with an initial learning rate of 0.1 and a hand-designed schedule that adapts to the variations of the validation set: if the validation accuracy does not improve, the learning rate is divided by a factor of 5. We also report results on Adam, since it is the other optimizer suggested in the official implementation released by the authors. Using their open-source implementation, we replace the optimization by the DFW algorithm, the CE loss by an SVM, and leave all other components unchanged. In this

8

Under review as a conference paper at ICLR 2019

experiment, we use the conditional gradient direction rather than the CE gradient, since three-way classification does not cause sparsity in the derivative of the hinge loss (which is the issue that originally motivated our use of a different direction). We cross-validate our initial proximal term as a power of ten, and do not manually tune any schedule. In order to disentangle the importance of the loss function from the optimization algorithm, we run the baselines with both an SVM loss and a CE loss. The initial learning rate of the baselines is also cross-validated as a power of ten.

Results. The results are presented in Table 3.

Optimizer

Adam Adam SGD SGD SGD DFW

Loss CE SVM CE CE SVM SVM

Test Accuracy (%) 84.5 85.0 84.5 84.7 85.2 85.3

Table 3: Results on the Stanford Natural Language Inference corpus. SGD refers to the result reported in (Conneau et al., 2017). The other results have been obtained with their open-source implementation in our own experiments.

Note that these results outperform the reported testing accuracy of 84.5% in (Conneau et al., 2017) that is obtained with CE. This experiment, which is performed on a completely different architecture and data set than the previous one, confirms that DFW outperforms adaptive gradient methods and matches the performance of SGD with a hand-designed learning rate schedule.
6 THE IMPORTANCE OF THE STEP-SIZE
6.1 IMPACT ON GENERALIZATION It is worth discussing the subtle relationship between optimization and generalization. As an illustrative example, consider the following experiment: we take the protocol to train the DN network on CIFAR-100 with SGD, and simply change the initial learning rate to be ten times smaller, and the budget of epochs to be ten times larger. As a result, the final training objective significantly decreases from 0.33 to 0.069. Yet at the same time, the best validation accuracy decreases from 70.94% to 68.7%. A similar effect occurs when decreasing the value of the momentum, and we have observed this across various convolutional architectures. In other words, accurate optimization is less important for generalization than the implicit regularization of a high learning rate. We have observed DFW to accurately optimize the learning objective in our experiments. However, given the above observation, we believe that its good generalization properties are rather due to its capability to usually maintain a high learning rate at an early stage. Similarly, the success of the generalization performance of SGD may be due to its schedule with a large number of steps at a high learning rate.
6.2 SENSITIVITY ANALYSIS The previous section has qualitatively hinted at the importance of the step-size for generalization. Here we quantitatively analyze the impact of the initial learning rate  on both the training accuracy (quality of optimization) and the validation accuracy (quality of generalization). We compare results of the DFW and SGD algorithms on the CIFAR data sets when varying the value of  as a power of 10. The results on the validation set are summarized in figure 4, and the performance on the training set in reported in Appendix B. On the training set, both methods obtain nearly perfect accuracy across at least three orders of magnitude of  (details in Appendix B.2). In contrast, the results of figure 4 confirm that the validation performance is sensitive to the choice of  for both methods. In some cases where  is high, SGD obtains a better performance than DFW. This is because the handdesigned schedule of SGD enforces a decay of , while the DFW algorithm relies on an automatic decay of the step-size t for effective convergence. This automatic decay may not happen if a small proximal term (large ) is combined with a local approximation that is not sufficiently accurate (for instance due to a small batch-size).

9

Under review as a conference paper at ICLR 2019

Validation Accuracy (%)

CIFAR10-WRN 100

80

60

40

20

0 DFW

SGD

CIFAR10-DN 100

80

60

40

20

0 DFW

SGD

 0.001 0.01 0.1 1.0
 0.001 0.01 0.1 1.0

Validation Accuracy (%)

Validation Accuracy (%)

CIFAR100-WRN 100

80

60

40

20

0 DFW

SGD

CIFAR100-DN 100

80

60

40

20

0 DFW

SGD

 0.001 0.01 0.1 1.0
 0.001 0.01 0.1 1.0

Validation Accuracy (%)

Figure 4: Visualization of the sensitivity analysis for the choice of initial learning rate  on the CIFAR data sets. Each subplot displays the best validation accuracy for DFW and SGD. Similar plots are available in larger format in Appendix B.2.

However, if we allow the DFW algorithm to use a larger batch size, then the local approximation becomes more accurate and it can handle large values of  as well. Interestingly, choosing a larger batch-size and a larger value of  can result in better generalization. For instance, by using a batchsize of 256 (instead of 64) and  = 1, DFW obtains a test accuracy of 72.64% on CIFAR-100 with the DN architecture (SGD obtains 70.33% with the settings of (Huang et al., 2017)).
6.3 DISCUSSION Our empirical evidence indicates that the initial learning rate can be a crucial hyper-parameter for good generalization. We have observed in our experiments that such a choice of high learning rate provides a consistent improvement for convolutional neural networks: accurate minimization of the training objective with large initial steps usually leads to good generalization. Furthermore, as mentioned in the previous section, it is sometimes beneficial to even increase the batch-size in order to be able to train the model using large initial steps. In the case of recurrent neural networks, however, this effect is not as distinct. Additional experiments on different recurrent architectures have showed variations in the impact of the learning rate and in the best-performing optimizer. Further analysis would be required to understand the effects at play.
7 CONCLUSION
We have introduced DFW, an efficient algorithm to train deep neural networks. DFW predominantly outperforms adaptive gradient methods, and obtains similar performance to SGD without requiring a hand-designed learning rate schedule. We emphasize the generality of our framework in Section 3, which enables the training of deep neural networks to benefit from any advance on optimization algorithms for linear SVMs. This framework could also be applied to other loss functions that yield efficiently solvable proximal problems. In particular, our algorithm already supports the use of structured prediction loss functions (Taskar et al., 2003, Tsochantaridis et al., 2004), which can be used, for instance, for image segmentation. We have mentioned the intricate relationship between optimization and generalization in deep learning. This illustrates a major difficulty in the design of effective optimization algorithms for deep neural networks: the learning objective does not include all the regularization needed for good generalization. We believe that in order to further advance optimization for deep neural networks, it is essential to alleviate this problem and expose a clear objective function to optimize.

10

Under review as a conference paper at ICLR 2019
REFERENCES
Marcin Andrychowicz, Misha Denil, Sergio Gomez, Matthew W Hoffman, David Pfau, Tom Schaul, Brendan Shillingford, and Nando De Freitas. Learning to learn by gradient descent by gradient descent. Neural Information Processing Systems, 2016.
Devansh Arpit, Stanislaw Jastrzebski, Nicolas Ballas, David Krueger, Emmanuel Bengio, Maxinder S. Kanwal, Tegan Maharaj, Asja Fischer, Aaron Courville, Yoshua Bengio, and Simon LacosteJulien. A closer look at memorization in deep networks. International Conference on Machine Learning, 2017.
Jimmy Ba, Roger Grosse, and James Martens. Distributed second-order optimization using kroneckerfactored approximations. International Conference on Learning Representations, 2017.
Francis Bach. Duality between subgradient and conditional gradient methods. SIAM Journal on Optimization, 2015.
Atilim Gunes Baydin, Robert Cornish, David Martinez Rubio, Mark Schmidt, and Frank Wood. Online learning rate adaptation with hypergradient descent. International Conference on Learning Representations, 2018.
Leonard Berrada, Andrew Zisserman, and M Pawan Kumar. Trusting SVM for piecewise linear CNNs. International Conference on Learning Representations, 2017.
Leonard Berrada, Andrew Zisserman, and M Pawan Kumar. Smooth loss functions for deep top-k classification. International Conference on Learning Representations, 2018.
Aleksandar Botev, Hippolyt Ritter, and David Barber. Practical gauss-newton optimisation for deep learning. International Conference on Machine Learning, 2017.
Samuel R Bowman, Gabor Angeli, Christopher Potts, and Christopher D Manning. A large annotated corpus for learning natural language inference. Conference on Empirical Methods in Natural Language Processing, 2015.
Sébastien Bubeck. Convex optimization: Algorithms and complexity. Foundations and Trends in Machine Learning, 2015.
Pratik Chaudhari and Stefano Soatto. Stochastic gradient descent performs variational inference, converges to limit cycles for deep networks. International Conference on Learning Representations, 2018.
Alexis Conneau, Douwe Kiela, Holger Schwenk, Loic Barrault, and Antoine Bordes. Supervised learning of universal sentence representations from natural language inference data. Conference on Empirical Methods in Natural Language Processing, 2017.
Guillaume Desjardins, Karen Simonyan, Razvan Pascanu, et al. Natural neural networks. Neural Information Processing Systems, 2015.
John Duchi, Elad Hazan, and Yoram Singer. Adaptive subgradient methods for online learning and stochastic optimization. Journal of Machine Learning Research, 2011.
Marguerite Frank and Philip Wolfe. An algorithm for quadratic programming. Naval Research Logistics Quarterly, 1956.
Thomas Frerix, Thomas Möllenhoff, Michael Moeller, and Daniel Cremers. Proximal backpropagation. International Conference on Learning Representations, 2018.
Surbhi Goel, Varun Kanade, Adam Klivans, and Justin Thaler. Reliably learning the ReLU in polynomial time. Conference on Learning Theory, 2017.
Roger Grosse and James Martens. A kronecker-factored approximate fisher matrix for convolution layers. International Conference on Machine Learning, 2016.
Moritz Hardt, Benjamin Recht, and Yoram Singer. Train faster, generalize better: Stability of stochastic gradient descent. International Conference on Machine Learning, 2016.
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recognition. Conference on Computer Vision and Pattern Recognition, 2016.
Uri Heinemann, Roi Livni, Elad Eban, Gal Elidan, and Amir Globerson. Improper deep kernels. International Conference on Artificial Intelligence and Statistics, 2016.
11

Under review as a conference paper at ICLR 2019
Sepp Hochreiter and Klaus Obermayer. Optimal gradient-based learning using importance weights. International Joint Conference on Neural Networks, 2005.
Elad Hoffer, Itay Hubara, and Daniel Soudry. Train longer, generalize better: closing the generalization gap in large batch training of neural networks. Neural Information Processing Systems, 2017.
Gao Huang, Zhuang Liu, Kilian Q Weinberger, and Laurens van der Maaten. Densely connected convolutional networks. Conference on Computer Vision and Pattern Recognition, 2017.
Diederik P. Kingma and Jimmy Ba. Adam: A method for stochastic optimization. International Conference on Learning Representations, 2015.
Alex Krizhevsky. Learning multiple layers of features from tiny images. Technical Report, 2009. Simon Lacoste-Julien, Martin Jaggi, Mark Schmidt, and Patrick Pletscher. Block-coordinate Frank-
Wolfe optimization for structural SVMs. International Conference on Machine Learning, 2013. Adrian S Lewis and Stephen J Wright. A proximal method for composite minimization. Mathematical Programming, 2016. Ke Li and Jitendra Malik. Learning to optimize. International Conference on Learning Representations, 2017. Ilya Loshchilov and Frank Hutter. SGDR: Stochastic gradient descent with warm restarts. International Conference on Learning Representations, 2017. James Martens and Roger Grosse. Optimizing neural networks with Kronecker-factored approximate curvature. International Conference on Machine Learning, 2015. James Martens and Ilya Sutskever. Training deep and recurrent networks with Hessian-free optimization. Neural Networks: Tricks of the Trade, 2012. James Martens, Jimmy Ba, and Matt Johnson. Kronecker-factored curvature approximations for recurrent neural networks. International Conference on Learning Representations, 2018. Pritish Mohapatra, Puneet Dokania, C. V. Jawahar, and M. Pawan Kumar. Partial linearization based optimization for multi-class SVM. European Conference on Computer Vision, 2016. Yurii Nesterov. A method of solving a convex programming problem with convergence rate O(1/k2). Soviet Mathematics Doklady, 1983. Behnam Neyshabur, Ruslan R Salakhutdinov, and Nati Srebro. Path-sgd: Path-normalized optimization in deep neural networks. Neural Information Processing Systems, 2015. Behnam Neyshabur, Yuhuai Wu, Ruslan R Salakhutdinov, and Nati Srebro. Path-normalized optimization of recurrent neural networks with relu activations. Neural Information Processing Systems, 2016. Behnam Neyshabur, Srinadh Bhojanapalli, David McAllester, and Nati Srebro. Exploring generalization in deep learning. Neural Information Processing Systems, 2017. Yann Ollivier. Riemannian metrics for neural networks. Information and Inference: a Journal of the IMA, 2013. Adam Paszke, Sam Gross, Soumith Chintala, Gregory Chanan, Edward Yang, Zachary DeVito, Zeming Lin, Alban Desmaison, Luca Antiga, and Adam Lerer. Automatic differentiation in pytorch. NIPS Autodiff Workshop, 2017. Sachin Ravi and Hugo Larochelle. Optimization as a model for few-shot learning. International Conference on Learning Representations, 2017. Sashank J Reddi, Satyen Kale, and Sanjiv Kumar. On the convergence of adam and beyond. International Conference on Learning Representations, 2018. Nicolas L Roux, Pierre-Antoine Manzagol, and Yoshua Bengio. Topmoumoute online natural gradient algorithm. Neural Information Processing Systems, 2008. David Rumelhart, Geoffrey Hinton, and Ronald Williams. Learning representations by backpropagating errors. Nature, 1986. Tom Schaul, Sixin Zhang, and Yann LeCun. No more pesky learning rates. International Conference on Machine Learning, 2013.
12

Under review as a conference paper at ICLR 2019
Karen Simonyan and Andrew Zisserman. Very deep convolutional networks for large-scale image recognition. International Conference on Learning Representations, 2015.
Gaurav Singh and John Shawe-Taylor. Faster convergence & generalization in DNNs. arXiv preprint, 2018.
Christian Szegedy, Wei Liu, Yangqing Jia, Pierre Sermanet, Scott Reed, Dragomir Anguelov, Dumitru Erhan, Vincent Vanhoucke, Andrew Rabinovich, et al. Going deeper with convolutions. Conference on Computer Vision and Pattern Recognition, 2015.
Benjamin Taskar, Carlos Guestrin, and Daphne Koller. Max-margin Markov networks. Neural Information Processing Systems, 2003.
Gavin Taylor, Ryan Burmeister, Zheng Xu, Bharat Singh, Ankit Patel, and Tom Goldstein. Training neural networks without gradients: A scalable ADMM approach. International Conference on Machine Learning, 2016.
Ioannis Tsochantaridis, Thomas Hofmann, Thorsten Joachims, and Yasemin Altun. Support vector machine learning for interdependent and structured output spaces. International Conference on Machine Learning, 2004.
Olga Wichrowska, Niru Maheswaranathan, Matthew W Hoffman, Sergio Gomez Colmenarejo, Misha Denil, Nando de Freitas, and Jascha Sohl-Dickstein. Learned optimizers that scale and generalize. International Conference on Machine Learning, 2017.
Ashia C Wilson, Rebecca Roelofs, Mitchell Stern, Nati Srebro, and Benjamin Recht. The marginal value of adaptive gradient methods in machine learning. Neural Information Processing Systems, 2017.
Xiaoxia Wu, Rachel Ward, and Léon Bottou. Wngrad: Learn the learning rate in gradient descent. arXiv preprint arXiv:1803.02865, 2018.
Alan L. Yuille and Anand Rangarajan. The concave-convex procedure (CCCP). Neural Information Processing Systems, 2002.
Sergey Zagoruyko and Nikos Komodakis. Wide residual networks. British Machine Vision Conference, 2016.
Matthew Zeiler. ADADELTA: an adaptive learning rate method. arXiv preprint, 2012. Yuchen Zhang, Percy Liang, and Martin J. Wainwright. Convexified convolutional neural networks.
International Conference on Machine Learning, 2017a. Ziming Zhang, Yuanwei Wu, and Guanghui Wang. Bpgrad: Towards global optimality in deep
learning via branch and pruning. Conference on Computer Vision and Pattern Recognition, 2017b.
13

Under review as a conference paper at ICLR 2019

A PROOFS & ALGORITHMS
For completeness, we prove results for our specific instance of Structural SVM problem. We point out that the proofs of sections A.1, A.2 and A.3 are adaptations from (Lacoste-Julien et al., 2013). Propositions are numbered according to their appearance in the paper.

A.1 PRELIMINARIES In this section, we assume the loss L to be a hinge loss:

Lhinge : (u, y)  R|Y| × Y  max max {uy¯ + 1 - uy} , 0
y¯Y \{y}

(8)

We suppose that we have received a sample (x, y). We simplify the notation f (w, x) = fx(w) and L(u, y) = Ly(u). For simplicity of the notation, and without loss of generality, we consider the proximal problem obtained at time t = 0:

min
wRp

1 2

w - w0

2 + Tw0 (w) + Ly (Tw0 fx(w))

.

(9)

Let us define the classification task loss:

For (y¯, y)  Y2, (y¯, y) =

0 1

if y¯ = y, otherwise.

(10)

Using this notation, the multi-class hinge loss can be written as: Lhinge(u, y) = max {uy¯ + (y¯, y) - uy} .
y¯Y
Indeed, we can successively write:

(11)

Lhinge(u, y) = max max {uy¯ + 1 - uy} , 0 ,
y¯Y \{y}

= max {max {uy¯ + 1 - uy, 0}} ,
y¯Y \{y}

= max {max {uy¯ + (y¯, y) - uy, 0}} ,
y¯Y \{y}

= max {max {uy¯ + (y¯, y) - uy, 0}} ,
y¯Y

=

max
y¯Y

{uy¯

+

(y¯,

y)

-

uy }

.

(12)

We are now going to re-write problem (9) as the sum of a quadratic term and a pointwise maximum of linear functions. For y¯  Y, let us define:

Then we have that:

ay¯ = (w) w0 + fx,y¯(w) w0 - fx,y(w) w0 , by¯ = (w0) + fx,y¯(w0) - fx,y(w0) + (y¯, y).

(13)

max
y¯Y

ay¯ (w - w0) + by¯

= max
y¯Y

((w) w0 + fx,y¯(w) w0 - fx,y(w) w0 ) (w - w0)

+ (w0) + fx,y¯(w0) - fx,y(w0) + (y¯, y) ,

= (w0) + (w) w0 (w - w0)

+ max
y¯Y

fx,y¯(w) w0 (w - w0) + fx,y¯(w0) + (y¯, y)

- fx,y(w0) - fx,y(w) w0 (w - w0), = Tw0 (w) + L (Tw0 fx(w), y) .

(14)

14

Under review as a conference paper at ICLR 2019

Therefore, problem (9) can be written as:

min
wRp

1 2

w - w0

2 + max
y¯Y

ay¯ (w - w0) + by¯

.

(15)

We notice that the term (w0) in b is a constant that does not depend on w nor y¯, therefore we can simplify the expression of b to:

by¯ = fx,y¯(w0) - fx,y(w0) + (y¯, y).

(16)

We introduce the following notation:

w^ = w - w0,

P

=

{



|Y |
R+

:

y¯ = 1},

y¯Y

A = (ay¯)y¯Y  Rp×|Y|.

(17) (18)
(19)

We will also use the indicator vector: 1y  R|Y|, which is equal to 1 at index y and 0 elsewhere.

A.2 DUAL OBJECTIVE

Lemma 1 (Dual Objective). The Lagrangian dual of (9) is given by:

max
P

-1 2

A

2+b



.

Given the dual variables , the primal can be computed as w^ = -A.

(20)

Proof. We derive the Lagrangian of the primal problem. For that, we write the problem in the following equivalent ways:

min
w^ Rp

1 2

w^ 2 + max
y¯Y

ay¯ w^ + by¯

,

min
w^ Rp

1 2

w^

2+

subject to: y¯  Y, ay¯ w^ + by¯  ,

R



min
w^ Rp R

sup
0

 

1 2

w^

2 +  + y¯
y¯Y

ay¯ w^ + by¯ - 

 ,




sup min  1

0

w^ Rp R



2

w^

2 +  + y¯
y¯Y

ay¯ w^ + by¯ - 

 

(by strong duality).

(21) (22) (23) (24)

(w^ ,,)
We can now write the KKT conditions of the inner minimization problem:

(w^ , , ) = 0 : 

(w^ , , w^

)

=

0

:

1 - y¯ = 0,

y¯Y

1 w^ + 

y¯ay¯ = 0.

y¯Y

(25)

This gives   P and w^ = -A, since A = (ay¯)y¯Y by definition. By injecting these constraints in (24), we obtain:

max
P

1 2

A 2 + -A

1 A + b 

,

(26)

which finally gives the desired result.

15

Under review as a conference paper at ICLR 2019

A.3 DERIVATION OF THE OPTIMAL STEP-SIZE

Lemma 2 (Optimal Step-Size). Suppose that we make a step in the direction of s  P in the dual. We define the corresponding primal variables ws = -As and s = b s, as well as  = b . Then the optimal step-size is given by:



=

(w

-

w0

- ws) (w - w0) + w - w0 - ws 2

(s

- ) .

(27)

Proof. Given the direction s, we take the step  + (s - ). The new objective is given by:

-1 2

A( + (s - ))

2+b

( + (s - )).

(28)

In order to compute the optimal step-size, we compute the derivative of the above expression with respect to gamma, and set it to 0:

- 1 (s - ) A A( + (s - )) + b (s - ) = 0. 
We can isolate the unique term containing :
- 1  A(s - ) 2 - 1 (s - ) A A + b (s - ) = 0. 
This yields:

(29) (30)



=

-

1 

(s

- )
1



A A + b A(s - ) 2

(s - ) ,

=

-

1 

(As

-

A)

A + b

1 

As - A

2

(s - ) ,

(31)

=

-(As - A) A + b As - A 2

(s - ) .

We can then inject the primal variables and simplify:



=

(-ws

+ w^ ) w^ + (s - ws + w^ 2

- ) ,

=

(w

-

w0

- ws) (w - w0) + w - w0 - ws 2

(s

- ) .

(32)

A.4 PRIMAL-DUAL PROXIMAL FRANK-WOLFE ALGORITHM We present here the primal-dual algorithm that solves (9) using the previous results:

Algorithm 2 Proximal Frank Wolfe Algorithm

Require: proximal coefficient , initial point w0  Rp, sample (x, y).

1: w1 = w0 - (w) w0 2: 1 = 0

Initialization w0 - A with  = 1y Initialization b  with  = 1y

3: t = 1

4: while not converged do

5: Choose direction st  P

(e.g. conditional gradient or smoothed loss)

6: ws = -Ast

7: s = b st

8:

t

=

(wt

-

w0

-

ws) (wt - w0) + w - w0 - ws 2

(s

-

t)

Optimal- step-size

9: wt+1 = (1 - t)wt + t(ws + w0)

At+1 = (1 - t)At + tAst

10: t+1 = (1 - t)t + ts

b t+1 = (1 - t)b t + tb st

11: t = t + 1

12: end while

16

Under review as a conference paper at ICLR 2019

Note that when fx is linear, and when the search direction s is given by the conditional gradient, we recover the standard Frank-Wolfe algorithm for SVM (Lacoste-Julien et al., 2013).

A.5 SINGLE-STEP PROXIMAL FRANK-WOLFE ALGORITHM

We now provide some simplification to the steps 6, 8 and 9 of Algorithm 2 when a single step is taken, as is the case in the DFW algorithm. This corresponds to the iteration t = 1.

Proposition 2 (Cost per iteration). If a single step is performed on the dual of (6), its conditional

gradient is given by - ((w) + Ly(fx(w)))

.
wt

The resulting update can be written as:

wt+1 = wt -  (w) wt + Lj (fj (w)) wt

(33)

Proof. It is known that for linear SVMs, the direction of the dual conditional gradient is given by the negative sub-gradient of the primal (Lacoste-Julien et al., 2013, Bach, 2015). We apply this result to the Taylor expansion of the network, which is the local model used for the proximal problem. Then we have that at iteration t = 1, the conditional gradient is given by:

-  (Tw0 (w) + Ly(Tw0 fx(w)))

.
w0

(34)

It now suffices to notice that a first-order Taylor expansion does not modify the derivative at its point

of linearization: for a chain rule to (34), we

ofbutnacintiothnat ,theTcwo0nd(itwio)nawl0g=radien(twis)

. By applying gwiv0en by:

this

property

and

the

-  ((w) + Ly(fx(w)))

.
w0

(35)

This completes the proof that the conditional gradient direction is given by a stochastic gradient. We

now prove equation (33) in the next lemma.

Lemma 3. Suppose that we apply the Proximal Frank-Wolfe algorithm with a single step. Let t =  st (fx,y¯(w0) - fx,y(w0))y¯Y and rt = w(w0). Then we can rewrite step 6 as:

ws = - [rt + t] .

(36)

In addition, we can simplify steps 8 and 9 of Algorithm 2 to:

t

=

-t 

rt + st t 2

b

clipped

to

[0,

1],

wt+1 = w0 -  [rt + tt] .

(37) (38)

Proof. Again, since we perform a single step of FW, we assume t = 1. To prove equation (36), we note that:
ws = -As,

= - (w) w0 + (fx,y¯(w) w0 - fx,y(w) w0 )y¯Y st ,

(39)

= - [rt + t] . We point out the two following results:

wt - w0 = w1 - w0 = -(w) w0 = -rt,

(40)

and:

wt - w0 - ws = -rt + rt + t = t.

(41)

Since 1 = 0 by definition, equation (37) is obtained with a simple application of equations 40 and 41. Finally, we prove equation 38 by writing:

wt+1 = (1 - t)wt + t(ws + w0), = (1 - t)(w0 - rt) + t(-rt - t + w0), = w0 - (rt + tt).

(42)

17

Under review as a conference paper at ICLR 2019

A.6 SMOOTHING THE LOSS
As pointed out in the paper, the SVM loss is non-smooth and has sparse derivatives, which can prevent the effective training of deep neural networks (Berrada et al., 2018). Partial linearization can solve this problem by locally smoothing the dual (Mohapatra et al., 2016). However, this would introduce a temperature hyper-parameter which is undesirable. Therefore, we note that DFW can be applied with any direction that is feasible in the dual, since it computes an optimal step-size. In particular, the following result states that we can use the well-conditioned and non-sparse gradient of cross-entropy. Proposition 3. The gradient of cross-entropy in the primal gives a feasible direction in the dual. Furthermore, we can inexpensively detect when this feasible direction cannot provide any improvement in the dual, and automatically switch to the conditional gradient when that is the case.
For simplicity, we divide Proposition 3 into two distinct parts: first we show how the CE gradient gives a feasible direction in the dual, and then how it can be detected to be an ascent direction. Lemma 4. The gradient of cross-entropy in the primal gives a feasible direction in the dual. In other words, the gradient of cross-entropy g in the primal is such that there exists a dual search direction s  P verifying g = -As.

Proof. We consider the vector of scores (fx,y¯(w))y¯Y  R|Y|. We compute its softmax: sce =

exp(fx,y¯(w)) jY exp(fx,j (w))

. Clearly, sce  P by property of the softmax. Furthermore, by going back
y¯Y

to the definition of A, one can easily verify that -Asce is exactly the primal gradient given by a

backward pass through the cross-entropy loss instead of the hinge loss. This concludes the proof.

The previous lemma has shown that we can use the gradient of cross-entropy as a feasible direction sce in the dual. The next step is to make it a dual ascent direction, that is a direction which always permits improvement on the dual objective (unless at the optimal point). In what follows, we show that we can inexpensively (approximately) compute a sufficient condition for sce to be an ascent direction. If the condition is not satisfied, then we can automatically switch to use the subgradient of the hinge loss (which is known as an ascent direction in the dual). Lemma 5. Let s  P be a feasible direction in the dual, and v = (Tw0 fx(wt)y¯ + (y¯, y) - Tw0 fx(wt)y)y¯Y  R|Y| be the vector of augmented scores output by the linearized model. Let us assume that we apply the single-step Proximal Frank-Wolfe algorithm (that is, we have t = 1), and that  is a non-negative function. Then s v > 0 is a sufficient condition for s to be an ascent direction in the dual.

Proof. Let s  P, v = (Tw0 fx(wt)y¯ + (y¯, y) - Tw0 fx(wt)y)y¯Y . By definition, we have that:

Therefore:

v = ay¯ (wt - w0) + by¯ - Tw0 (w) y¯Y ,

= 1A 

(wt - w0) + b - (Tw0 (w))y¯Y .

(43)

s v>0



1 

(As)

(wt - w0) + s

b-s

(Tw0 (w))y¯Y > 0,

 (As) (wt - w0) + s b - Tw0 (w) > 0, (since s  P and  > 0)

 - ws (wt - w0) + s b - (w0) - (w0) (wt - w0) > 0,

(44)

 - ws (wt - w0) + s b - (w0) + (wt - w0) (wt - w0) > 0,

 (wt - w0 - ws) (wt - w0) + s b - (w0) > 0,

= (wt - w0 - ws) (wt - w0) + s b > 0, (because (w0)  0)  t > 0 (we have that t = 0 at t = 1).

We have just shown that if s v > 0, then t > 0. Since t is an optimal step-size, this indicates that s is an ascent direction (we would obtain t = 0 for a direction s that cannot provide improvement).

18

Under review as a conference paper at ICLR 2019

Approximate Condition. wisetyhpaivcealtlhyavt erTyws0mfxa(lwl ()w-e

In practice, fx(w0) =

we O(

consider that wt - w0 ),

aTnwd0

use a weight decay coefficient in

fx(wt) fx(w0). Indeed, for t = 1, wt - w0 = w(w0)) , which the order of 1e-4 in our experimen-

itnalexspetetninsigvse).siTncheerfexf(owre0,)wisearlerepaladcyecTowm0pfuxt(ewd )bybythfexf(owrw0)aridn

the above pass.

criterion,

which

becomes

A.7 NESTEROV MOMENTUM

As can be seen in the previous primal-dual algorithms, taking a step in the dual can be decomposed

into two stages: the initialization and the movement along the search direction. The initialization

step is not informative about the optimization problem. Therefore, we discard it from the momentum

velocity, and only accumulate the step along the conditional gradient (scaled by t). This results in the following velocity update:

zt+1 = µzt - t(rt + t).

(45)

19

Under review as a conference paper at ICLR 2019

B EXPERIMENTAL DETAILS ON THE CIFAR DATA SETS
B.1 ADAPTIVE GRADIENT BASELINES: CROSS-VALIDATION

l2
0.0001 0.0001 0.0001 0.0001


0.001 0.01 0.1
1

Accuracy CIFAR-10 (%)
71.6 88.18 86.4 68.48

Accuracy CIFAR-100 (%)
39.44 55.72 55.44 20.68

Table 4: Cross-Validation for ADAGRAD on DN architecture (best validation accuracy obtained during training).

l2
0.0001 0.0001 0.0001 0.0005 0.0005 0.0005


0.001 0.01 0.1 0.001 0.01 0.1

Accuracy CIFAR-10 (%)
68.98 86.4 83.6 68.66 86.3 77.92

Accuracy CIFAR-100 (%)
31.86 53.82 51.18 32.5 56.16 44.12

Table 5: Cross-Validation for ADAGRAD on WRN architecture (best validation accuracy obtained during training).

l2
0.0001 0.0001 0.0001


0.0001 0.001 0.01

Accuracy CIFAR-10 (%)
86.26 89.42 81.12

Accuracy CIFAR-100 (%)
50.7 63.9 51.82

Table 6: Cross-Validation for ADAM on DN architecture (best validation accuracy obtained during training).

l2
0.0001 0.0001 0.0001 0.0005 0.0005 0.0005


0.0001 0.001 0.01 0.0001 0.001 0.01

Accuracy CIFAR-10 (%)
79.7 86.1 80.06 78.88 85.14 72.54

Accuracy CIFAR-100 (%)
41.42 58.7 50.86 40.08 55.26 36.82

Table 7: Cross-Validation for ADAM on WRN architecture (best validation accuracy obtained during training).

20

Under review as a conference paper at ICLR 2019

l2
0.0001 0.0001 0.0001


0.0001 0.001 0.01

Accuracy CIFAR-10 (%)
84.28 90.4 83.98

Accuracy CIFAR-100 (%)
49.54 68.54 50.44

Table 8: Cross-Validation for AMSGRAD on DN architecture (best validation accuracy obtained during training).

l2
0.0001 0.0001 0.0001 0.0005 0.0005 0.0005


0.0001 0.001 0.01 0.0001 0.001 0.01

Accuracy CIFAR-10 (%)
75.86 87.02 82.32 75.74 86.16 75.82

Accuracy CIFAR-100 (%)
41.6 59.6 52.12 42.28 57.82 36.48

Table 9: Cross-Validation for AMSGRAD on WRN architecture (best validation accuracy obtained during training).

l2
0.0001 0.0001 0.0001 0.0001


0.001 0.01 0.1
1

Accuracy CIFAR-10 (%)
72.72 83.26 91.7 10.16

Accuracy CIFAR-100 (%)
40.96 53.12 59.7 1.16

Table 10: Cross-Validation for BPGRAD on DN architecture (best validation accuracy obtained during training).

l2
0.0001 0.0001 0.0001 0.0001 0.0005 0.0005 0.0005 0.0005


0.001 0.01 0.1
1 0.001 0.01
0.1 1

Accuracy CIFAR-10 (%)
64.98 78.46 89.24 16.1 68.08 85.44 88.44 10.16

Accuracy CIFAR-100 (%)
31.9 44.26 54.42 1.16 33.26 59.9 51.28 1.16

Table 11: Cross-Validation for BPGRAD on WRN architecture (best validation accuracy obtained during training).

B.2 SGD & DFW: SENSITIVITY ANALYSIS We provide here a sensitivity analysis of the DFW algorithm on its hyper-parameter , and we compare it against the SGD algorithm with its custom schedule.
21

Under review as a conference paper at ICLR 2019

Accuracy (%)

Accuracy (%)

CIFAR10-WRN

Split = Train

Split = Val

100

80

60

40

20

0 DFW

SGD

Optimizer

DFW

Optimizer

SGD

Figure 5: Sensitivity analysis on the WRN architecture and CIFAR-10 data set.

 0.001 0.01 0.1 1.0

CIFAR10-DN

Split = Train 100

Split = Val

80

60

40

20

0 DFW

SGD

Optimizer

DFW

Optimizer

SGD

Figure 6: Sensitivity analysis on the DN architecture and CIFAR-10 data set.

 0.001 0.01 0.1 1.0

CIFAR100-WRN

Split = Train

Split = Val

100

80

60

40

20

0 DFW

SGD

Optimizer

DFW

Optimizer

SGD

Figure 7: Sensitivity analysis on the WRN architecture and CIFAR-100 data set.

 0.001 0.01 0.1 1.0

CIFAR100-DN

Split = Train 100

Split = Val

80

60

40

20

0 DFW

SGD

Optimizer

DFW

Optimizer

SGD

Figure 8: Sensitivity analysis on the DN architecture and CIFAR-100 data set.

 0.001 0.01 0.1 1.0

22

Accuracy (%)

Accuracy (%)

Under review as a conference paper at ICLR 2019

C EXPERIMENTAL DETAILS ON THE SNLI DATA SET
C.1 CROSS-VALIDATION


1e-05 0.0001 0.001 0.01

Accuracy CE (%)
83.18 84.56 84.42 33.82

Accuracy SVM (%)
83.02 84.69 83.31 33.82

Table 12: Cross-Validation for ADAM (best validation accuracy obtained during training).

 Accuracy (%) 0.1 84.87 1.0 85.21 10 84.76
Table 13: Cross-Validation for DFW (best validation accuracy obtained during training).

 Accuracy CE (%) Accuracy SVM (%)

0.01 84.22 0.1 84.63 1.0 85.06 10 34.59

84.59 85.06 84.7 34.51

Table 14: Cross-Validation for SGD (best validation accuracy obtained during training).

23

