Under review as a conference paper at ICLR 2018
MARGINAL POLICY GRADIENTS: A UNIFIED FAMILY OF ESTIMATORS FOR BOUNDED ACTION SPACES WITH APPLICATIONS
Anonymous authors Paper under double-blind review
ABSTRACT
Many complex domains, such as robotics control and real-time strategy (RTS) games, require an agent to learn a continuous control. In the former, an agent learns a policy over Rd and in the latter, over a discrete set of actions each of which is parametrized by a continuous parameter. Such problems are naturally solved using policy based reinforcement learning (RL) methods, but unfortunately these often suffer from high variance leading to instability and slow convergence. Unnecessary variance is introduced whenever policies over bounded action spaces are modeled using distributions with unbounded support by applying a transformation T to the sampled action before execution in the environment. Recently, the variance reduced clipped action policy gradient (CAPG) was introduced for actions in bounded intervals, but to date no variance reduced methods exist when the action is a direction, something often seen in RTS games. To this end we introduce the angular policy gradient (APG), a stochastic policy gradient method for directional control. With the marginal policy gradients family of estimators we present a unified analysis of the variance reduction properties of APG and CAPG; our results provide a stronger guarantee than existing analyses for CAPG. Experimental results on a popular RTS game and a navigation task show that the APG estimator offers a substantial improvement over the standard policy gradient.
1 INTRODUCTION
Recent work in deep reinforcement learning (RL) has achieved human level-control for complex tasks like Atari 2600 games and the ancient game of Go. Mnih et al. (2015) show that it is possible to learn to play Atari 2600 games using end to end reinforcement learning. Other authors (Silver et al., 2014) derive algorithms tailored to continuous action spaces, such as appear in problems of robotics control. Today, solving RTS games is a major open problem in RL (Foerster et al., 2016; Usunier et al., 2017; Vinyals et al., 2017); these are more challenging than previously solved game domains because the action and state spaces are far larger. In RTS games, actions are no longer chosen from a relatively small discrete action set as in other game types. Neither is the objective solely learning a continuous control. Instead the action space typically consists of many discrete actions each of which has a continuous parameter. For example, a discrete action in an RTS game might be moving the player controlled by the agent with a parameter specifying the movement direction. Because the agent must learn a continuous parameter for each discrete action, a policy gradient method is a natural approach to an RTS game. Unfortunately, obtaining stable, sample-efficient performance from policy gradients remains a key challenge in model-free RL.
Just as robotics control tasks often have actions restricted to a bounded interval, Multi-player Online Battle Arena (MOBA) games, an RTS sub-genre, often have actions restricted to the unit sphere which specify a direction (e.g. to move or attack). The current practice, despite most continuous control problems having bounded action spaces, is to use a Gaussian distribution to model the policy and then apply a transformation T to the action a before execution in the environment. This support mismatch between the sampling action distribution (i.e. the policy ), and the effective action distribution can both introduce bias to and increase the variance of policy gradient estimates (Chou et al., 2017; Fujita and Maeda, 2018). For an illustration of how the distribution over actions a is transformed under T (a) = a/||a||, see Figure 1 in Section 3.
1

Under review as a conference paper at ICLR 2018
In this paper, motivated by an application to a MOBA game, we study policy gradient methods in the context of directional actions, something unexplored in the RL literature. Like CAPG for actions in an interval [, ], our proposed algorithm, termed angular policy gradient (APG), uses a variance-reduced, unbiased estimated of the true policy gradient. Since the key step in APG is an update based on an estimate of the policy gradient, it can easily be combined with other state-of-the art methodology including value function approximation and generalized advantage estimation (Sutton et al., 2000; Schulman et al., 2016), as well as used in policy optimization algorithms like TRPO, A3C, and PPO (Schulman et al., 2015; Mnih et al., 2016; Schulman et al., 2017).
Beyond new methodology, we also introduce the marginal policy gradients (MPG) family of estimators; this general class of estimators contains both APG and CAPG, and we present a unified analysis of the variance reduction properties of all such methods. Because marginal policy gradient methods have already been shown to provide substantial benefits for clipped actions (Fujita and Maeda, 2018), our experimental work focuses only on angular actions; we use a marginal policy gradient method to learn a policy for the 1 vs. 1 map of the King of Glory game and the Platform2D-v1 navigation task, demonstrating improvement over several baseline policy gradient approaches.
1.1 RELATED WORK
Model-Free RL. Policy based methods are appealing because unlike value based methods they can support learning policies over discrete, continuous and parametrized action spaces. It has long been recognized that policy gradient methods suffer from high variance, hence the introduction of trust region methods like TRPO and PPO (Schulman et al., 2015; 2017). Mnih et al. (2016) leverage the independence of asynchronous updating to improve stability in actor-critic methods. See Sutton and Barto (2018) for a general survey of reinforcement learning algorithms, including policy based and actor-critic methods. Recent works have applied policy gradient methods to parametrized action spaces in order to teach an agent to play RoboCup soccer (Hausknecht and Stone, 2016; Masson et al., 2016). Formally, a parametrized action space A over K discrete, parametrized actions is defined as A := k{(k, ) :   k}, where k  [K] and k is the parameter space for the kth action. See Appendix B.5 for rigorous discussion of the construction of a distribution over parametrized action spaces and the corresponding policy gradient algorithms.
Bounded Action Spaces. Though the action space for many problems is bounded, it is nonetheless common to model a continuous action using the multivariate Gaussian, which has unbounded support (Hausknecht and Stone, 2016; Florensa et al., 2017; Finn et al., 2017). Until recently, the method for dealing with this type of action space was to sample according to a Gaussian policy and then either (1) allow the environment to clip the action and update according to the unclipped action or (2) clip the action and update according to the clipped action (Chou et al., 2017). The first approach suffers from unnecessarily high variance, and the second approach is off-policy.
Recent work considers variance reduction when actions are clipped to a bounded interval (Chou et al., 2017; Fujita and Maeda, 2018). Depending upon the way in which the Q-function is modeled, clipping has also been shown to introduce bias (Chou et al., 2017). Previous approaches are not applicable to the case when T is the projection onto the unit sphere; in the case of clipped actions, unlike previous work, we do not require that each component of the action is independent and obtain much stronger variance reduction results. Concurrent work (Fellows et al., 2018) also considers angular actions, but their method cannot be used as a drop in replacement in state of the art methods and the a special form of the critic q is required.
Integrated Policy Gradients. Several recent works have considered, as we do, exploiting an integrated form of policy gradient (Ciosek and Whiteson, 2018; Asadi et al., 2017; Fujita and Maeda, 2018; Tamar et al., 2012). Ciosek and Whiteson (2018) introduces a unified theory of policy gradients, which subsumes both deterministic (Silver et al., 2014) and stochastic policy gradients (Sutton et al., 2000). They characterize the distinction between different policy gradient methods as a choice of quadrature for the expectation. Their Expected Policy Gradient algorithm uses a new way of estimating the expectation for stochastic policies. They prove that the estimator has lower variance than stochastic policy gradients. Asadi et al. (2017) propose a similar method, but lack theoretical guarantees. Fujita and Maeda (2018) introduce the clipped action policy gradient (CAPG) which is a partially integrated form of policy gradient and provide a variance reduction guarantee, but their result is not tight. By viewing CAPG as a marginal policy gradient we obtain tighter results.
2

Under review as a conference paper at ICLR 2018

Variance Decomposition. The law of total variance, or variance decomposition, is given by Var[Y ] = E[Var(Y |X)] + Var[E[Y |X]], where X and Y are two random variables on the same probability space. Our main result can be viewed as a special form of law of total variance, but it
is highly non-trivial to obtain the result directly from the law of total variance. Also related to our
approach is Rao-Blackwellization (Blackwell, 1947) of a statistic to obtain a lower variance estimator, though in our case it is the fact that T (a) is not sufficient for the sampling distribution that enables the variance reduction.

2 PRELIMINARIES

Notation and Setup. For MDP's we use the standard notation. S is the state space, A is the

action space, p denotes the transition probability kernel, p0 the initial state distribution, r the reward

function. A policy (a|s) is a distribution over actions given a state s  S. A sample trajectory

vquanl(dusee,rafu) n:i=cstidoEenn[oisteddte=fi0netd:r=ta+s1(vs|s00,(as=)0,:sr=,1a, E0s1=,[aa1,]t..=.T0.h)etwrothb+ej1er|ecst0isv0=e iss]tpoa0nmdaantxdhiemaaitzcetioexnp-v(e·ac|lstuete)d.

The statefunction as
cumulative

discounted reward, () = Ep0 [v(s0)].  denotes the improper discounted state occupancy

distribution, defined as  := t tEp0 [P(st = s|s0, )]. We make the standard assumption of

bounded rewards.

We consider the problem of learning a policy  parametrized by   . All gradients are with respect

to



unless

otherwise

stated.

By

convention,

we

define

0·



=

0

and

0 0

=

0.

A

measurable

space

(A, E) is a set A with a sigma-algebra E of subsets of A. When we refer to a probability distribution

of a random variable taking values in (A, E) we will work directly with the probability measure on

(A, E) rather than the underlying sample space. For a measurable mapping T from measure space

(A, E, ) to measurable space (B, F ), we denote by T the push-forward of . Sd-1 denotes the unit sphere in Rd and for any space A, B(A) denotes the Borel -algebra on A. The notation µ 

signifies the measure µ is absolutely continuous with respect to . The function clip is defined as

clip(a, , ) = min(, max(, a)) for a  R. If a  Rd, it is interpreted element-wise.

Variance of Random Vectors. We define the variance of a random vector y as Var(y) = E[(y - Ey) (y - Ey)], i.e. the trace of the covariance of y; it is easy to verify standard properties of the variance still hold. This definition is often used to analyze the variance of gradient estimates
(Greensmith et al., 2004).

Stochastic Policy Gradients. In Section 4 we present marginal policy gradient estimators and work in the very general setting described below. Let (A, E, µ) be a measure space, where as before A is the action space of the MDP. In practice, we often encounter (A, E) = (Rd, B(Rd)) with µ as the Lebesgue measure. The types of policies for which there is a meaningful notation of stochastic policy gradients are µ-compatible measures (see remarks 2.3 and 2.4).
Definition 2.1 (µ-Compatible Measures). Let (A, E, µ) be a measure space and consider a parametrized family of measures  = {(·, ) :   } on the same space.  is a µ-compatible family of measures if for all :
(a) (·, ) µ with density of the form f(·, ),
(b) f is differentiable in , and
(c)  satisfies the conditions to apply the Leibniz integral rule for each , so that  A f(a)dµ = A f(a)dµ.

For µ-compatible policies, Theorem 2.2 gives the stochastic policy gradient, easily estimable from samples. When µ is the counting measure we recover the discrete policy gradient theorem (Sutton et al., 2000). See Appendix A.1 for a more in depth discussion and a proof of Theorem 2.2, which we include for completeness.
Theorem 2.2 (Stochastic Policy Gradient). Let (A, E, µ) be a measure space and let  = {(·, |s) :   } be a family of µ-compatible probability measures. Denoting by f the density with respect to µ, we have that

 = d(s) q(s, a) log f(a|s)d(·|s).
SA

3

Under review as a conference paper at ICLR 2018

In general we want an estimate g of  such that it is unbiased (E[g] = ) and that has minimal variance, so that convergence to a (locally) optimal policy is as fast as possible. In the following sections, we explore a general approach to finding a low variance, unbiased estimator.
Remark 2.3. Under certain choices of T (e.g. clipping) the effective action distribution is a mixture of a continuous distribution and point masses. Thus, although it adds some technical overhead, it is necessary that we take a measure theoretic approach in this work.
Remark 2.4. Definition 2.1 is required to ensure the policy gradient is well defined, as it stipulates the existence of an appropriate reference measure; it also serves to clarify notation and to draw a distinction between  and its density f. Though these details are often minimized they are important in analyzing the interaction between T and .

3 ANGULAR POLICY GRADIENTS

Consider the task of learning a policy over directions in A = R2, or equivalently learning a policy over angles [0, 2). A naive approach is to fit the mean µ(s), model the angle as normally distributed about µ, and then clip the sampled angle before execution in the environment. However, this approach is asymmetric in that does not place similar probability on µ(s) - and µ(s) + for µ(s) near to 0 and 2.
An alternative is to model µ(s)  R2, sample a  N (µ(s), ), and then execute T (a) := a/||a|| in the environment. This method also works for directional control in Rd. The drawback of this approach is the following: informally speaking, we are sampling from a distribution with d degrees of freedom, but the environment is affected by an action with only d - 1 degrees of freedom. This suggests, and indeed we later prove, that the variance of the stochastic policy gradient for this
distribution is unnecessarily high. In this section we introduce the angular policy gradient which can
be used as a drop-in replacement for the policy update step in existing algorithms.

Angular Actions: Density of 

Angular Actions: T (a) = a/||a||

Angular Actions: Density of T

a T

T (a)

Figure 1: Transformation of a Gaussian policy ­ (left to right) (·|s), T = a/||a||, and T(·|s).

ANGULAR GAUSSIAN DISTRIBUTION

Instead, we can directly model T (a)  Sd-1 instead of a  Rd. If a  N (µ(s), (s)), then T (a) is distributed according to what is known as the angular Gaussian distribution (Definition 3.1). It can be derived by a change of variables to spherical coordinates, followed by integration with respect to the magnitude of the random vector (Paine et al., 2018). Figure 1 illustrates the transformation of a Gaussian sampling policy  under T .
Definition 3.1 (Angular Gaussian Distribution). Let a  N (µ, ). Then, with respect to the spherical measure  on (Sd-1, B(Sd-1)), x = a/||a|| has density

f (x; µ, ) = (2)d-1||(x -1x)d -1/2 exp

1 2

2 - µ

-1µ

Md-1(),

(3.1)

where 

=

x -1µ (x -1x)1/2

and Md-1(x)

=

(2

)-

1 2

 0

ud-1

exp(-(u

-

x)2/2)du.

4

Under review as a conference paper at ICLR 2018

POLICY GRADIENT METHOD

Although the density in Definition 3.1 does not have a closed form, we can still obtain a stochastic policy gradient for this type of policy. Define the action space as A := Sd-1 and consider angular Gaussian policies parametrized by  := (µ, ), where µ parametrizes µ and  parametrizes . As before, denote the corresponding parametrized family of measures as  := {(·, |s) :   }.
Directly from Definition 3.1, we obtain

log f

=

1 2

2 - µ

-1µ

+

log

Md-1()

-

1 2

(d - 1) log 2 + log || + d log

x

x

.

Though this log-likelihood does not have a closed form, it turns out it is easy to compute the gradient in practice. It is only necessary that we can evaluate Md-1() and Md() easily. Assuming for now that we can do so, denote by i the parameters after i gradient updates and define

li()

:=

1 2

2 - µ

-1µ

+

Md-1((i)) Md-1((i))



-

1 2

(d - 1) log 2 + log || + d log

x

x

.

(i)

By design,  log f()|=i = li()|=i ,
thus at update i it suffices to compute the gradient of li, which can be done using standard auto-
differentiation software (Paszke et al., 2017) since term (i) is a constant. From Paine et al. (2018), we have that Md() = dMd-1(), Md+1() = Md() + dMd-1(), M1() = () + () and M0() = (), where ,  denote the PDF and CDF of N (0, 1), respectively. Leveraging these properties, the integral Md() can be computed recursively; Algorithm 1 in Appendix B.1 gives psuedo-code for the computation. Importantly it runs in O(d) time and therefore does not effect the computational cost of the policy update since it is dominated by the cost of computing li. In
addition, stochastic gradients of policy loss functions for TRPO or PPO Schulman et al. (2015; 2017) can be computed in a similar way since we can easily get the derivative of f() when Md-1() and Md-1() are known.

4 MARGINAL POLICY GRADIENT ESTIMATORS

In Section 2, we described a general setting in which a stochastic policy gradient theorem holds on a measure space (A, E, ) for a family of -compatible probability measures,  = {(·, |s) :   }. As before, we are interested in the case when the dynamics of the environment only depend on a  A via a function T . That is to say r(s, a) := r(s, T (a)) and p(s, a, s ) := p(s, T (a), s ).
The key idea in Marginal Policy Gradient is to replace the policy gradient estimate based on the log-likelihood of  with a lower variance estimate, which is based on the log-likelihood of T. T can be thought of as (and in some cases is) a marginal distribution, hence the name Marginal Policy Gradient. For this reason it can easily be used with value function approximation and GAE, as well as incorporated into algorithms like TRPO, A3C and PPO.

4.1 SETUP AND REGULARITY CONDITIONS
For our main results we need regularity Condition 4.1 on the measure space (A, E, ). Next, let (B, F) be another measurable space and T : A  B be a measurable mapping. T induces a family of probability measures on (B, F ), denoted T := {T(·, |s) :   }. We also require regularity Conditions 4.2 and 4.3 regarding the structure of F and the existence of a suitable reference measure µ on (B, F). These conditions are all quite mild and are satisfied in all practical settings, to the best of our knowledge. Condition 4.1 . A is a metric space and  is a Radon measure.1
Condition 4.2 . F is countably generated and contains the singleton sets {b}, for all b  B.
Condition 4.3 . There exists a -finite measure µ on (B, F ) such that T µ and T is µcompatible.
1On a metric space A, a Radon measure is a measure defined on the Borel -algebra for which each compact K  A, (K) <  and for all B  B(A), (B) = supKB (K) where K is compact.

5

Under review as a conference paper at ICLR 2018

In statistics, Fisher information is used to capture the variance of a score function. In reinforcement
learning, typically one encounters a score function that has been rescaled by a measurable function q(a). Definition 4.4 provides a notion of Fisher information for -compatible distributions and rescaled score functions; we defer a discussion of the definition until Section 4.4 after we present our results in their entirety. If q(a) = 1, Definition 4.4 is the trace of the classical Fisher Information.
Definition 4.4 (Total Scaled Fisher Information). Let (A, E, ) be a measure space,  = {(·, ) :   } be a family of -compatible probability measures, and q a measurable function on E. The total scaled fisher information is defined as I,(q, ) := E[q(a)2 log f(a)  log f(a)].

4.2 VARIANCE REDUCTION GUARANTEE

From Theorem 2.2 it is immediate that

() = d(s) q(T (a), s) log f(a|s)d(a|s)
SA

= d(s) q(b, s) log fT(b|s)d(T)(b|s),
SB

where we dropped the subscripts on  and q because the two polices affect the environment in the same

way, and thus have the same value function and discounted state occupancy measure. Denote the two
alternative gradient estimators as g1 = q(T (a), s) log f(a|s) and g2 = q(b, s) log fT(b|s). Just by definition, we have that E,[g1] = E,[g2]. Lemma 4.5 says something slightly different ­ it says that they are also equivalent in expectation conditional on the state s, a fact we use later.

Lemma 4.5. Let (A, E, ) and (B, F, µ) be measure spaces, and T : A  B be measurable mapping. If , parametrized by , is -compatible and T is µ-compatible, then

E|s [g1] = E|s [g2] = ET|s [g2] .

(4.1)

Proof. The result follows immediately from the proof of Theorem 2.2 in Appendix A.1.

Because the two estimates g1 and g2 are both unbiased, it is always preferable to use whichever has lower variance. Theorem 4.6 shows that g2 is the lower variance policy gradient estimate. See Appendix B.3 for the proof. The implication of Theorem 4.6 is that if there is some information loss via a function T before the action interacts with the dynamics of the environment, then one obtains a lower variance estimator of the gradient by replacing the density of  with the density of T in the expression for the policy gradient.
Theorem 4.6. Let g1 and g2 be as defined above. Then if Conditions 4.1-4.3 are satisfied,
Var,(g1) - Var,T(g2) = E,T I|s|b,b (q  T, )  0,
for some family of measures {b} on A. Furthermore, if T is not a sufficient statistic for ,
E,T I|s|b,b (q  T , ) > 0.

4.3 EXAMPLES OF MARGINAL POLICY GRADIENT ESTIMATORS

CLIPPED ACTION POLICY GRADIENT

Consider a control problem where actions in R are clipped to an interval [, ]. Let  be an arbitrary measure on (A, E) := (R, B(R)), and consider any -compatible family . Following Fujita and
Maeda (2018), define the clipped score function

 log 

(-,] f(a, |s)d

(s, b, ) =  log f(b, |s)

 log [,) f(a, |s)d

b= b  (, ) b = .

We can apply Theorem 4.6 in this setting to obtain Corollary 4.7. It is a strict generalization of the
results in Fujita and Maeda (2018) in that it applies to a larger class of measures and provides a much
stronger variance reduction guarantee. It is possible to obtain this more powerful result precisely because we require minimal assumptions for Theorem 4.6. Note that the result can be extended to Rd, but we stick to R for clarity of presentation. See Appendix B.4 for a discussion of which distributions are -compatible and a proof of Corollary 4.7.

6

Under review as a conference paper at ICLR 2018
Corollary 4.7. Let  be an arbitrary measure on (A, E) := (R, B(R)), T (a) := clip(a, , ), and (s, a, ) :=  log f(a, |s). If  is a -compatible family parametrized by  and the dynamics of the environment depend only on T (a), then 1. E|s [q(s, a)(s, a, )] = E|s q(s, a)(s, T (a), ) , and 2. Var,(q(s, a)(s, a, )) - Var,(q(s, a)(s, T (a), )) = E ET|s I|s|b,b (q  T, ) ,
for some family of measures {b} on A.
ANGULAR POLICY GRADIENT
Now consider the case where we sample an action a  Rd and apply T (a) = a/||a|| to map into Sd-1. Let (A, E) = (Rd, B(Rd)) and let  be the Lebesgue measure. When  is a multivariate Gaussian family parametrized by , T is an angular Gaussian family also parametrized by  (Section 3). If  is -compatible ­ here it reduces to ensuring the parametrization is such that f is differentiable in  ­ then T is -compatible, where  denotes the spherical measure. Denoting by fMV (a, |s) and fAG(b, |s) the corresponding multivariate and angular Gaussian densities, respectively, we state the results for this setting as Corollary 4.8. See Appendix B.4 for a proof. Corollary 4.8. Let  be the Lebesgue measure on (A, E) = (Rd, B(Rd)), T (a) := a/||a|| and  be a multivariate Gaussian family on A parametrized by . If the dynamics of the environment only depend on T (a) and fMV (·, |s), the density corresponding to , is differentiable in , then 1. E|s [q(s, a)(s, a, )] = E|s q(s, a)(s, T (a), ) , and 2. Var,(q(s, a)(s, a, )) - Var,(q(s, a)(s, T (a), )) = E,T Var|b(q(s, a)r(s, r, )) , where r = ||a||, fr is the conditional density of r, (s, a, ) :=  log fMV (a, |s), (s, b, ) =  log fAG(b, |s), and r(s, r, ) =  log fr(r, |s).
PARAMETRIZED ACTION SPACES
As one might expect, our variance reduction result applies to parametrized action spaces when a lossy transformation Ti is applied to the parameter for discrete action i. See Appendix B.5 for an in depth discussion of policy gradient methods for parametrized action spaces.
4.4 DISCUSSION
Denoting by g1 the standard policy gradient estimator for a -compatible family , observe that Var,(g1) = I,(q, ). We introduce the quantity I, because unless T is a coordinate projection it is not straightforward to write Theorem 4.6 in terms of the density of a conditional distribution. Corollary 4.8 can be written this way because under a re-parametrization to polar coordinates, T (a) = a/||a|| can be written as a coordinate projection. In general, by using I, we can phrase the result in terms of a quantity with an intuitive interpretation: a (q-weighted) measure of information contained in a that does not influence the environment.
Recalling the law of total variation (LOTV), we can observe that Theorem 4.6 is indeed specific version of that general result. We can not directly apply the LOTV because in the general setting, it is highly non-trivial to conclude that g2 is a version of the conditional expectation of g1, and for arbitrary policies, one must be extremely careful when making the conditioning argument (Chang and Pollard, 1997). However for certain special cases, like CAPG, we can check fairly easily that g2 = E[g1|b].
5 APPLICATIONS AND DISCUSSION
5.1 2D NAVIGATION TASK
Because relatively few existing reinforcement learning environments support angular actions, we implement a navigation task to benchmark our methods2. In this navigation task, the agent is located
2We have made this environment and the implementation used for the experiments available on-line. We temporarily removed the link from this paper to preserve anonymity.
7

Under review as a conference paper at ICLR 2018
on a platform and must navigate from one location to another without falling off. The state space is S = R2, the action space is A = R2 and the transformation T (a) = a/||a|| is applied to actions before execution in the environment. Let sG = (1, 1) be the goal (terminal) state. Using the reward shaping approach (Ng et al., 1999), we define a potential function (s) = ||s - sG||2 and a reward function as r(st, at) = (st) - (st + at). The start state is fixed at s0 = (-1, -1). One corner of the platform is located at (-1.5, -1.5) and the other at (1.5, 1.5).
We compare angular Gaussian policies with (1) bivariate Gaussian policies and (2) a 1-dimensional Gaussian policy where we model the mean of the angle directly, treating angles that differ by 2 as identical. For all candidate policies, we use A2C (the synchronous version of A3C (Mnih et al., 2016)) to learn the conditional mean µ(s; ) of the sampling distribution by fitting a feed-forward neural network with tanh activations. The variance of the sampling distribution, 2I, is fixed. For the critic we estimate the state value function v(s), again using a feed-forward neural network. Appendix C.1 for details on the hyper-parameter settings, network architecture and training procedure.
5.2 APPLICATION ­ KING OF GLORY
We implement a marginal policy gradient method for King of Glory (the North American release is titled Arena of Valor) by Tencent Games. King of Glory has several game types and we focus on the 1v1 version. Our work here is one of the first attempts to solve King of Glory, and MOBA games in general, using reinforcement learning. Similar MOBA games include Dota 2 and League of Legends.
Game Description. In King of Glory, players are divided into two "camps" located in opposite corners of the game map. Each player chooses a "hero", a character with unique abilities, and the objective is to destroy the opposing team's "crystal", located at their game camp. The path to each camp and crystal is guarded by towers which attack enemies when in range. Each team has a number of allied "minions", less powerful characters, to help them destroy the enemy crystal. Only the "hero" is controlled by the player. During game play, heroes increase in level and obtain gold by killing enemies. This allows the player to upgrade the level of their hero's unique skills and buy improved equipment, resulting in more powerful attacks, increased HP, and other benefits. Figure 2 shows King of Glory game play; in the game pictured, both players use the hero "Di Ren Jie".
Formulation as an MDP. A is a parametrized action space with 7 discrete actions, 4 of which are parametrized by   R2. These actions include move, attack, and use skills; a detailed description of all actions and parameters is given in Table 3, Appendix C.2. In our setup, we use rules crafted by domain experts to manage purchasing equipment and learning skills. The transformation T (a) = a/||a|| is applied to the action parameter before execution in the environment, so the effective action parameter spaces are S1.
Using information obtained directly from the game engine, we construct a 2701-dimensional state representation. Features extracted from the game engine include hero locations, hero health, tower health, skill availability and relative locations to towers and crystals ­ see Appendix C.2 for details on the feature extraction process. As in Section 5.1, we define rewards using a potential function. In particular we define a reward feature mapping  and a weighting vector w, and then a linear potential function as r(s) = wT (s). Information extracted by  includes hero health, crystal health, and game outcome; see Table 5, Appendix C.2 for a complete description of w and . Using r, we can define the reward as rt = r(st) - r(st-1).
Implementation. We implement the A3C algorithm, and model both the policy  and the value function v using feed-forward neural networks. See Appendix C.2 for more details on how we model and learn the value function and policy. Using the setup described above, we compare: 1. a standard policy gradient approach for parametrized action spaces, and 2. a marginal (angular) policy gradient approach, adapted to the parametrized action space where
Ti(a) = a/||a|| is applied to parameter i. Additional details on both approaches can be found in Appendix B.5.
5.3 RESULTS
For the navigation task, the top row of Figure 2 contains, from left to right, cumulative, discounted reward trajectories, and two plots showing the variances of the competing estimators. We see that the
8

Cumulative Reward

Under review as a conference paper at ICLR 2018

Platform2D-v1

0.4 0.3 0.2 0.1 0.0
0

Policy Angular Gaussian Multivariate Gaussian 1D Gaussian

5000

10000

15000

20000

25000

Number of Updates

Log Variance

Cumulative Reward

Gradient Variance vs. Sampling Variance ­ Trained
-6 Policy
-7 Angular Gaussian Multivariate Gaussian
-8
-9
-10
-11
-12
0.05 0.10 0.15 0.20 0.25 

0.4 0.3 0.2 0.1 0.0 -0.1 -0.2
0

King of Glory 1v1
Policy Angular Gaussian Multivariate Gaussian

1000

2000

3000

Number of Episodes

4000

Log Variance

Win Rate

Gradient Variance vs. Sampling Variance ­ Untrained 2 Policy
Angular Gaussian 1 Multivariate Gaussian
0
-1
-2
-3
0.05 0.10 0.15 0.20 0.25 
King of Glory 1v1 Policy
0.8 Angular Gaussian Multivariate Gaussian
0.6

0.4

0.2

0.0

0

1000

2000

3000

4000

Number of Episodes

Figure 2: On top are results for Platform2D-v1; on bottom, results for King of Glory 1v1 and a screenshot of game play.

agent using the angular policy gradient converges faster compared to the multivariate Gaussian due to the variance reduced gradient estimates. The second baseline also performs worse than APG, likely due in part to the fact that the critic must approximate a periodic function. Only APG achieves the maximum possible cumulative, discounted reward. On the King of Glory 1 vs. 1 task, the agent is trained to play as the hero Di Ren Jie and training occurs by competing with the game's internal AI, also playing as Di Ren Jie. The bottom row of Figure 2 shows the results, and as before, the angular policy gradient outperforms the standard policy gradient by a significant margin both in terms of win percentage and cumulative discounted reward.

In addition, Figure 2 highlights the effects of Theorem 4.6 in practice. The plot in the center shows

the variance at the start of training, for a fixed random initialization, and the plot on the right shows

the variance for a trained model that converged to the optimal policy. The main difference between

the two settings is that the value function estimate v is highly accurate for the trained model (since

both actor and critic have converged) and highly inaccurate for the untrained model. In both cases,

we

see

that

the

variance

of

the

marginal

policy

gradient

estimator

is

roughly

1 2

that

of

the

estimator

using the sampling distribution.

5.4 DISCUSSION
Motivated by challenges found in complex control problems, we introduced a general family of variance reduced policy gradients estimators. This view provides the first unified approach to problems where the environment only depends on the action through some transformation T , and we demonstrate that CAPG and APG are members of this family corresponding to different choices of T . We also show that it can be applied to parametrized action spaces. Because thorough experimental work has already been done for the CAPG member of the family (Fujita and Maeda, 2018), confirming the benefits of MPG estimators, we do not reproduce those results here. Instead we focus on the case when T (a) = a/||a|| and demonstrate the effectiveness of the angular policy gradient approach on King of Glory and our own Platform2D-v1 environment. Although at this time few RL environments use directional actions, we anticipate the number will grow as RL is applied to newer and increasingly complex tasks like MOBA games where such action spaces are common. We also envision that our methods can be applied to autonomous vehicle, in particular quadcopter, control.

9

Under review as a conference paper at ICLR 2018
REFERENCES
ASADI, K., ALLEN, C., RODERICK, M., MOHAMED, A.-R., KONIDARIS, G. and LITTMAN, M. (2017). Mean Actor Critic. arXiv:1709.00503.
BLACKWELL, D. (1947). Conditional expectation and unbiased sequential estimation. Annals of Mathematical Statistics 18 105­110.
CHANG, J. T. and POLLARD, D. (1997). Conditioning as disintegration. Statistica Neerlandica 51 287­317.
CHOU, P.-W., MATURANA, D. and SCHERER, S. (2017). Improving Stochastic Policy Gradients in Continuous Control with Deep Reinforcement Learning using the Beta Distribution. In ICML.
CIOSEK, K. and WHITESON, S. (2018). Expected Policy Gradients for Reinforcement Learning. arXiv:1801.03326.
FELLOWS, M., CIOSEK, K. and WHITESON, S. (2018). Fourier Policy Gradients. In ICML.
FINN, C., ABBEEL, P. and LEVINE, S. (2017). Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks. In ICML.
FLORENSA, C., DUAN, Y. and ABBEEL, P. (2017). Stochastic Neural Networks for Hierarchical Reinforcement Learning. In ICLR.
FOERSTER, J. N., ASSAEL, Y. M., DE FREITAS, N. and WHITESON, S. (2016). Learning to Communicate with Deep Multi-Agent Reinforcement Learning. In NIPS.
FUJITA, Y. and MAEDA, S.-I. (2018). Clipped Action Policy Gradient. In ICML.
GREENSMITH, E., BARTLETT, P. L. and BAXTER, J. (2004). Variance Reduction Techniques for Gradient Estimates in Reinforcement Learning. Journal of Machine Learning Research 5 1471­1530.
HAUSKNECHT, M. and STONE, P. (2016). Deep Reinforcement Learning In Parameterized Action Space. In ICLR.
KINGMA, D. P. and BA, J. L. (2015). Adam: A Method for Stochastic Optimization. In ICLR.
KLAMBAUER, G., UNTERTHINER, T., MAYR, A. and HOCHREITER, S. (2017). Self-Normalizing Neural Networks. In NIPS.
MASSON, W., RANCHOD, P. and KONIDARIS, G. (2016). Reinforcement Learning with Parameterized Actions. In AAAI.
MNIH, V., KAVUKCUOGLU, K., SILVER, D., RUSU, A. A., VENESS, J., BELLEMARE, M. G., GRAVES, A., RIEDMILLER, M., FIDJELAND, A. K., OSTROVSKI, G., PETERSEN, S., BEATTIE, C., SADIK, A., ANTONOGLOU, I., KING, H., KUMARAN, D., WIERSTRA, D., LEGG, S. and HASSABIS, D. (2015). Human-level control through deep reinforcement learning. Nature 529­533.
MNIH, V., PUIGDOME` NECH BADIA, A., MIRZA, M., GRAVES, A., HARLEY, T., LILLICRAP, T. P., SILVER, D., KAVUKCUOGLU, K., COM, K. and DEEPMIND, G. (2016). Asynchronous Methods for Deep Reinforcement Learning. In ICML.
NG, A., HARADA, D. and RUSSELL, S. (1999). Policy invariance under reward transformations: Theory and application to reward shaping. In ICML.
PAINE, P. J., PRESTON, S. P., TSAGRIS, M. and WOOD, A. T. A. (2018). An elliptically symmetric angular Gaussian distribution. Statistics and Computing 28 689­697.
PASZKE, A., CHANAN, G., LIN, Z., GROSS, S., YANG, E., ANTIGA, L. and DEVITO, Z. (2017). Automatic differentiation in PyTorch. In NIPS Workshop.
SCHULMAN, J., LEVINE, S., MORITZ, P., JORDAN, M. and ABBEEL, P. (2015). Trust Region Policy Optimization. In ICML.
10

Under review as a conference paper at ICLR 2018
SCHULMAN, J., MORITZ, P., LEVINE, S., JORDAN, M. and ABBEEL, P. (2016). High-Dimensional Continuous Control Using Generalized Advantage Estimation. In ICLR.
SCHULMAN, J., WOLSKI, F., DHARIWAL, P., RADFORD, A. and OPENAI, O. K. (2017). Proximal Policy Optimization Algorithms. arXiv:1707.06347.
SILVER, D., HEESS, N., DEGRIS, T., WIERSTRA, D. and RIEDMILLER, M. (2014). Deterministic Policy Gradient Algorithms. In ICML.
SUTTON, R. S. and BARTO, A. G. (2018). Reinforcement learning: an introduction. SUTTON, R. S., MCALLESTER, D., SINGH, S. and MANSOUR, Y. (2000). Policy Gradient Methods
for Reinforcement Learning with Function Approximation. In NIPS. TAMAR, A., DI CASTRO, D. and MEIR, R. (2012). Integrating a partial model into model free
reinforcement learning. Journal of Machine Learning Research 13 1927­1966. USUNIER, N., SYNNAEVE, G., LIN, Z. and CHINTALA, S. (2017). Episodic Exploration for Deep
Deterministic Policies: An Application to StarCraft Micromanagement Tasks. In ICLR. VINYALS, O., EWALDS, T., BARTUNOV, S., GEORGIEV, P., VEZHNEVETS, A. S., YEO, M.,
MAKHZANI, A., UTTLER, H., AGAPIOU, J., SCHRITTWIESER, J., QUAN, J., GAFFNEY, S., PETERSEN, S., SIMONYAN, K., SCHAUL, T., VAN HASSELT, H., SILVER, D., LILLICRAP, T., CALDERONE, D. K., KEET, P., BRUNASSO, A., LAWRENCE, D., EKERMO, A., REPP, J. and BLIZZARD, R. T. (2017). StarCraft II: A New Challenge for Reinforcement Learning. arXiv:.1708.04782.
11

Under review as a conference paper at ICLR 2018

A ADDITIONAL PRELIMINARIES

This section contains additional preliminary material and discussion thereof.

A.1 DISCUSSION ­ STOCHASTIC POLICY GRADIENTS
We require a stochastic policy gradient theorem that can be applied to distributions on arbitrary measurable spaces in order to rigorously analyze the Marginal Policy Gradients framework. Let the notation be as in Section 2. The first ingredient is Proposition A.1, which gives a very general form of policy gradient, defined for an arbitrary probability measure. Proposition A.1. [Ciosek and Whiteson (2018)] Let (·|s) be a probability measure on (A, E), then

 = d(s) v(s) - d(a|s)q(s, a) .
SA
This is an important step towards the form of stochastic policy gradient theorem we need in order to present our unified analysis that includes measures with uncountable support and also those which do not admit a density with respect to Lebesgue measure ­ something frequently encountered in practice. To obtain a stochastic policy gradient theorem from Proposition A.1 we simply need to replace v(s) with an appropriate expression. As in Ciosek and Whiteson (2018), we need to be able to justify an interchange along the lines of

v =  d(a|s)q(s, a) = da(a|s)q(s, a) + d(a|s)q(s, a).

AA

A

(A.1)

Such an expression doesn't make sense for arbitrary , so we must be precise regarding the conditions under which such an expression makes sense and the interchange is permitted, hence Definition 2.1. Because we did not find a statement with the sort of generality we required in the literature, we give a proof of our statement the stochastic policy gradient theorem, Theorem 2.2, below.

Proof of Theorem 2.2. The proof follows standard arguments. Because  is µ-compatible we obtain that
v =  d(a|s)q(s, a)
A
=  [q(s, a)f(a|s)] dµ
A
= q(s, a)f(a|s)dµ + q(s, a)d(a|s).
AA
The result now follows immediately from Proposition A.1.

A.2 DISINTEGRATION THEOREMS
The definitions and propositions below are from Chang and Pollard (1997), which we include here for completeness. Let (A, E, ) be a measure space and (B, F) a measurable space. Let  be a -finite measure on E and µ be a -finite measure on F. Definition A.2 ((T, µ)-disintegration, Chang and Pollard (1997)). The measure  has a (T, µ)disintegration, denoted {b} if for all nonnegative measurable f on A
· b is a -finite measure on E that is concentrated on Eb := {T = b} in the sense that A I[A \ Eb]db = 0 for µ-almost all b,
· the function b  T -1(b) f db is measurable, and
· A f d = B T -1(b) f dbdµ.
If µ = T, then we call b a T -disintegration. With some additional assumptions, we have the existence theorem given below.

12

Under review as a conference paper at ICLR 2018

Proposition A.3 (Existence, Chang and Pollard (1997)). Let A be a metric space,  be a -finite Radon measure, and µ be a -finite measure such that T µ. If F is countably generated and contains the singleton sets {b}, then  has a (T, µ)-disintegration. The measures {b} are unique up to an almost-sure equivalence in that if {b } is another (T, µ)-disintegration, µ({b : b = b}) = 0.
Lastly, we have Proposition A.4 which characterizes the properties of disintegrations and how they relate to densities and push-forward measures.
Proposition A.4 (Chang and Pollard (1997)). Let  have a (T, µ)-disintegration {b}, and let  be absolutely continuous with respect to  with a finite density r(a), where each of , µ and  is -finite. Then

·  has a (T, µ)-disintegration {b} where b b with density r(a),

· T µ with density rT (b) := T -1(b) r(a)db,

· the measures {b} are finite for µ almost all b if and only if T is -finite,

· the measures {b} are probabilities for µ almost all b if and only if µ = T, and

· if T is -finite, then T({b : rT (b) = 0}) = 0 and T({b : rT (b) = }) = 0. For T-almost all b, the measures {b} defined by

f (a)db =
T -1(b)

f (a)ra|b(a)db
T -1(b)

and

ra|b(a)

:=

I[0

<

rT

(b)

<

]

r(a) rT (b)

,

are probability measures that give a T -disintegration of .

13

Under review as a conference paper at ICLR 2018
B THEORY AND METHODOLOGY
This section contains additional theoretical and methodology results, including our crucial scaled Fisher information decomposition theorem.
B.1 ANGULAR POLICY GRADIENT
Algorithm 1 shows how to compute Md(), allowing us to easily find the angular policy gradient.
Algorithm 1 Computing Md() for Angular Policy Gradient Input: d,  Output: Md() 1: M0  () 2: M1  () + () 3: if d > 1 then 4: for i = 2, . . . , d do 5: Mi  Mi-1 + dMi-2 6: end for 7: end if 8: return Md
B.2 FISHER INFORMATION DECOMPOSITION
Using the disintegration results stated in Appendix A.2, we now can state and prove our key decomposition result, Theorem B.1, used in the proof of our main result. Theorem B.1 (Fisher Information Decomposition). Let (A, E, ) be a measure space, (B, F) be a measurable space, T : A  B be a measurable, surjective mapping, and q a measurable function on F. Consider a -compatible family of probability measures  = {(·, ) :   } on E and denote T := {T(·, ) :   }, a family of measures on F . If
(a) A is a metric space,  is a Radon measure, and T µ for a -finite measure µ on F; (b) F is countably generated and contains the singleton sets {b};
(c) T is a µ-compatible family for a measure µ on F ;
then
1.  has a (T, µ)-disintegration {b}; 2. |b is a b-compatible family of probability measures that give a T -disintegration of ; 3. for any measurable function q : B  R,
I,(q  T, ) = ET I|b,b (q  T, ) + IT,µ(q, ).
Proof of Theorem B.1. To simplify matters, we assume without loss of generality that all densities are strictly positive. This is allowed because if some density is zero on part of its domain, we can just replace the associated measure with its restriction to sets where the density is non-zero. The conditions to apply Proposition A.3 are satisfied, so  has a (T, µ)-disintegration {b}, which proves claim 1. Next, denote by g(a) =  log f(a) and h(b) =  log fT(b). Because the
14

Under review as a conference paper at ICLR 2018

conditions to apply Proposition A.4 are satisfied, we obtain that

q(T (a))2g(a) g(a)d(a) =

q(T (a))2g(a) g(a)fa|b(a)db(a)dT(b)

A B T -1(b)

= q(b)2

g(a) g(a)fa|b(a)db(a)dT(b)

B T -1(b)

= q(b)2

 log f(a)  log f(a) fa|b(a)db(a)dT(b).

B T -1(b)

(B.1)

Denoting by |b the probability measure with density fa|b, we see that |b := {|b(·, ) :   } is a b-compatible family of probability measures, proving claim 2.
If we denote E|b[g] = T -1(b) g(a)fa|b(a)db(a), we further obtain that

(B.1) = q(b)2E|b[ log fa|b(a)  log fa|b(a)]dT(b)
B
+ 2 q(b)2 log fT (b) E|b[ log fa|b(a)]dT(b)
B
(i)
+ q(b)2E|b[ log fT (b)  log fT (b)]dT(b).
B
In the equation above, term (i) is 0 because E|b[ log fa|b(a)] = 0. Thus we get that

(B.1) = q(b)2E|b[ log fa|b(a)  log fa|b(a)]dT(b) + q(b)2 log fT (b)  log fT (b)dT(b)
BB
= q(T (a))2 log fa|b(a)  log fa|b(a)d(a) + q(b)2 log fT (b)  log fT (b)dT(b).
AB
(B.2)
Because a density is unique almost-everywhere, we can replace fT with fT in (B.2), giving claim 3:
E q(T (a))2g(a) g(a) = ET q(b)2E|b  log fa|b(a)  log fa|b(a) + ET q(b)2h(b) h(b)

I,(q  T, ) = ET I|b,b (q  T, ) + IT,µ(q, ).

B.3 PROOF OF THEOREM 4.6

First, we decompose the variance of g1 as

Var,(g1) = Var E|s [g1] + E Var|s [g1] .

(B.3)

A similar decomposition holds for g2. By combining Lemma 4.5 with (B.3) and its equivalent for g2, we get that
Var,(g1) - Var,T(g2) = E Var|s [g1] - VarT|s [g2] .
For any fixed s, applying the definition of variance given in Section 2 and Lemma 4.5 gives

Var|s [g1] - Var|s [g2] = E|s g1 g1 - g2 g2 . By applying Theorem B.1 (see Appendix B.2), to E|s g1 g1 we obtain
E|s g1 g1 - g2 g2 = ET I|b,b (q  T, ) . The result follows from combining (B.4) and (B.5), concluding the proof.

(B.4) (B.5)

15

Under review as a conference paper at ICLR 2018

B.4 MARGINAL POLICY GRADIENTS FOR CLIPPED AND NORMALIZED ACTIONS
For the clipped action setting, we give an example of a -compatible family for which Corollary 4.7 can be applied. Example B.2 (The Gaussian is -compatible). Let (A, E) := (R, B(R)) and  be the Lebesgue measure. Consider , a Gaussian family parametrized by   . If  is constrained such that the variance is lower bounded by > 0,  is -compatible.
Below are proofs of Corollaries 4.7 and 4.8 from Section 4.

Proof of Corollary 4.7. First, it is clear T is measurable, and it is easy to confirm that Conditions
4.1-4.3 hold. Next, define µ =  +  + , where  is understood to be its restriction to (, ). As defined, µ is a mixture measure on B and we can easily check that T is µ-compatible. In fact, the density of T(·, |s) is given by


 

(-,] f(a, )d

fT(b, ) = f(b, )

 

[,) f(a, )d

b= b  (, ) b = .

By applying Theorem 4.6 and observing

Var,(q(s, a)(s, T (a), )) = Var,T(q(s, b)(s, b, )), the proof is complete.

Proof of Corollary 4.8. First, it is clear T is measurable. Second, fMV differentiable in  implies  is -compatible. This also implies fAG, the density of T, is differentiable in  and therefore T is -compatible, where  is the spherical measure on (B, F ) = (Sd-1, B(Sd-1)). It is straightforward to confirm that the remainder of Conditions 4.1-4.3 hold. Applying Theorem 4.6 completes the
proof.

B.5 POLICY GRADIENTS FOR PARAMETRIZED ACTION SPACES

First we derive a stochastic policy gradient for parametrized action spaces, which we can do by writing down the policy distribution and applying 2.2. Recall a parametrized action space with K

discrete actions is defined as

A := {(k, ) :   k},

k

where k  {1, . . . , K}.

CONSTRUCTION OF A POLICY FAMILY

Masson et al. (2016) gives a definition for a policy over parametrized action spaces, and our definition is the same in spirit, but for our purposes we need to be careful in formalizing the construction. Our construction here is also a bit more general.
Informally, we can think of a policy over a parametrized action space as a mixture model, where k  [K] is a latent state. To formally define a policy family on A, the idea will be to construct a density function f that is differentiable in its parameter . We proceed as follows:

1. Let (k, Ek, µk) be measure spaces.
2. For k  [K]: specify k = {(·, |s) :   }, a µk-compatible family of probability measures on (k, Ek). Denote the corresponding densities by fk.
3. Denote by µ0 the counting measure on (A0, B(A0)) = (R, B(R)), and specify 0 = {(·, |s) :   } a µ0-compatible family of probability measures, parametrized by 0 and supported on [K]. Denote the corresponding density by f0.
4. Let  := (i)i, and define

f((k, ), |s) :=

f0(k, 0|s)fk(, k|s) 0

if (k, )  A otherwise.

16

Under review as a conference paper at ICLR 2018
To finish the policy construction, we need an appropriate -algebra E and reference measure µ such that f is a measurable and A fdµ = 1. In fact it is not difficult to construct E and µ in terms of (Ei)i and (µi)i, respectively, but we do not go into detail here. Assuming such a construction exists, we can define  a µ-compatible family of policies, parametrized by  = (i)i. STOCHASTIC POLICY GRADIENT Let (A, E, µ) and  be as constructed above. By applying Theorem 2.2, () can be estimated from samples by
g(s, a, ) := q(s, a) log f(a, |s) = q(s, a) log f0(k, 0|s) + q(s, a) log fk(, k|s). (B.6)
RESTRICTED ACTION PARAMETERS The second term in (B.6) is simply the policy gradient for a µk-compatible family on (k, Ek, µk). Let (Bk, Fk) be a measurable space and consider the setting in which we apply a measurable function Tk : Ak  Bk to the action parameters before execution in the environment. Assume the conditions are satisfied to apply Theorem 4.6, and denote by fk, the density of Tk with respect to an appropriate reference measure. Then we can replace q(s, a) log fk(, k|s) with q(s, a) log fk,(Tk(), k|s) in (B.6) to obtain the lower variance estimator g(s, a, ) := q(s, a) log f(a, |s) = q(s, a) log f0(k, 0|s)+q(s, a) log fk,(Tk(), k|s).
(B.7)
17

Under review as a conference paper at ICLR 2018

C DETAILS FOR APPLICATIONS
This section contains additional details on the experiments and results in Sections 5.1 and 5.2.
C.1 2D NAVIGATION
We run each setup 24 times from a random initialization. To create the cumulative reward trajectory plots in Figure 2 we (1) use k-NN regression to interpolate the cumulative discounted rewards on each run, and (2) using the cumulative discounted rewards from each sample trajectory, plot the average curve with a 95% confidence band. Table 1 gives the hyper-parameters used in the experiments on the Platform2D-v1 environment.

Table 1: Hyper-parameter settings used in training

Hyperparameter

Setting

Num. Workers Optimizer Learning Rate   No. Layers: Policy Net Width: Policy Net No. Layers: Value Net Width: Value Net

4 SGD 0.01 0.1 0.99 2 32 2 32

C.2 KING OF GLORY
Here we provide details on modeling for King of Glory, the experimental procedure and the tables referenced in Section 5.2.

STATE REPRESENTATION

A detailed description of all the features can be found below in Table 4. After extracting features,
we take the outer product of the feature vector with itself to capture dependencies between features. To be precise, first define 0 to be the 74-dimensional initial feature extraction. The featurized state representation (s) is defined by

((s))i,j :=

(0(s))i(0(s))j (0(s))i

for i = j, for i = j.

By symmetry, we use only the lower triangular portion of the matrix defined above giving a (74 × 73)/2 + 74 = 2775 dimensional feature vector that is input to the policy and value networks.

MODELING THE POLICY AND VALUE FUNCTION
The value network is modeled using a feed-forward neural network which takes as input (s). The sampling policy is a mixture, where the mixing distribution is over the 7 discrete actions, and a Gaussian distribution is used for each parameter space. We model the policy using 5 networks, one of which represents the distribution over the discrete actions by a fully connected feed-forward neural network into a 7-way softmax. For the parameters, we model the mean of the sampling distribution using a feed-forward network. The variance of the sampling distribution for the action parameters is 2I where  is learned by the agent. All action parameters share the same  and all 5 networks share weights up to the last layer.

LEARNING THE POLICY
The agent is trained to play as the hero Di Ren Jie and training is against the game's internal AI, also playing as Di Ren Jie. For both methods, 10 agents are trained for 5000 episodes each. During

18

Under review as a conference paper at ICLR 2018

training the cumulative discounted reward of each episode and game outcome are tracked. The hyper-parameters we used for the neural network structure and the A3C algorithm are shown in Table 2. To construct the plots in Figure 2, we apply a low pass filter to each trajectory and then plot the average curve with a 95% confidence band.
Like Mnih et al. (2015) and others do for the Atari Learning Environment, we employ frame-skipping; two out of every three frames are skipped. Because our reward is defined in terms of a state potential function, rewards from the skipped states are still captured. For training, we use the Adam algorithm (Kingma and Ba, 2015). No parameters are shared between different networks and all networks use SElu activation functions (Klambauer et al., 2017). Table 2 contains various hyper-parameter settings we used.

Table 2: Hyper-parameter settings used in training

Hyperparameter

Setting

Num. Workers N Optimizer
Actor Learning Rate
Critic Learning Rate  No. Hidden Layers: Policy Net Width: Policy Net Activation: Policy Net No. Hidden Layers: Value Net Width: Value Net Activation: Value Net

8
128 Adam ( = (0.5, 0.9)) 10-6 10-3 0.99
2
(128,96)
SELU
2
(128,96)
SELU

Table 3: Parametrized action space for King of Glory

Action

Parameter Dimension Description

no action move attack skill 1 skill 2 skill 3 recovery skill

0 2 0 2 2 2 0

agent does nothing move in direction 
hero uses its normal attack hero uses skill 1 towards direction  hero uses skill 2 towards direction  hero uses skill 3 towards direction 
hero uses the recovery skill to heal itself

19

Under review as a conference paper at ICLR 2018

Feature
position: our hero position: enemy hero position: enemy hero, relative position: enemy tower, relative
position: enemy minion, relative position: our spring, relative in tower range: our hero in tower range: enemy hero attacked by tower skill cool down: our hero skill cool down: enemy hero HP: our hero HP: enemy hero HP: nearest minion HP: nearest tower HP: minions in range alive: our hero alive: enemy hero gold: our hero gold: enemy hero gold:  EP: our hero EP: enemy hero hero state: our hero
hero state: enemy hero

Table 4: State features for King of Glory

Dimension Range

Description

2 [-1, 1]2 x,y coordinates of our hero's position

2 [-1, 1]2 x,y coordinates of enemy hero's position

3 R3 distance, direction to enemy hero 4 R4 distance, distance relative to attack range, relative direction to the near-

est enemy tower

3 R3 distance, relative direction to the nearest enemy minion 3 R3 distance, relative direction to our life spring 3 {0, 1}3 is our hero in the range of the enemy's towers

3 {0, 1}3 is enemy hero in the range of our tower

3 {0, 1}3 are the enemy towers are attacking our hero

5 [-1, 1]5 normalized cool down time for our hero's skills

5 [-1, 1]5 normalized cool down time for enemy hero's skills

1 [-1, 1] our hero's health points

1 [-1, 1] enemy hero's health points

1 [-1, 1] health points of the nearest enemy minion

1 [-1, 1] health points of the nearest enemy tower

1 R+ sum of HP of all the minions in the attack range of our hero

1

{0, 1}

whether our hero is alive

1

{0, 1}

whether enemy hero is alive

1

[0, 1]

our hero's gold

1

[0, 1]

enemy hero's gold

1 [-1, 1] difference between our hero's gold and enemy hero's gold

1 [-1, 1] normalized energy points of our hero

1 [-1, 1] normalized energy points of enemy hero

13 [0, 1]13 our hero's level, experience, current money, kill count, death count, as-

sist count, total money, attack range, physical attack, magical attack,

move speed, health points, energy points

13 [0, 1]13 enemy hero's level, experience, current money, kill count, death count,

assist count, total money, attack range, physical attack, magical attack,

move speed, health points, energy points

Table 5: State features and weights used in reward design

Feature

Weight

Description

gold difference HP (our hero) hurt to enemy hero hurt to enemy kill dead difference distance to our life spring distance to enemy tower HP difference crystal HP difference skill hit rate win/loss

0.5 0.5 0.5 1.0 1.0 0.25×(1.0 - HP) 0.125×HP 1.0 2.0 0.15 2.0

difference between the amount of our hero and enemy hero health points of our hero total amount of hurt from our hero to enemy hero total amount of hurt from our hero to all the enemies difference between kill count and dead count distance from our hero to spring distance from our hero nearest enemy difference between HP of our tower and enemy tower difference between HP of our crystal and enemy crystal percent of emitted skills that hit enemy hero game result

Notes
HP  [0, 1] HP  [0, 1]

20

