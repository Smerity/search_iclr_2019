Under review as a conference paper at ICLR 2019
HINDSIGHT POLICY GRADIENTS
Anonymous authors Paper under double-blind review
ABSTRACT
A reinforcement learning agent that needs to pursue different goals across episodes requires a goal-conditional policy. In addition to their potential to generalize desirable behavior to unseen goals, such policies may also enable higher-level planning based on subgoals. In sparse-reward environments, the capacity to exploit information about the degree to which an arbitrary goal has been achieved while another goal was intended appears crucial to enable sample efficient learning. However, reinforcement learning agents have only recently been endowed with such capacity for hindsight. In this paper, we demonstrate how hindsight can be introduced to policy gradient methods, generalizing this idea to a broad class of successful algorithms. Our experiments on a diverse selection of sparse-reward environments show that hindsight leads to a remarkable increase in sample efficiency.
1 INTRODUCTION
In a traditional reinforcement learning setting, an agent interacts with an environment in a sequence of episodes, observing states and acting according to a policy that ideally maximizes expected cumulative reward. If an agent is required to pursue different goals across episodes, its goal-conditional policy may be represented by a probability distribution over actions for every combination of state and goal. This distinction between states and goals is particularly useful when the probability of a state transition given an action is independent of the goal pursued by the agent.
Learning such goal-conditional behavior has received significant attention in machine learning and robotics, especially because a goal-conditional policy may generalize desirable behavior to goals that were never encountered by the agent (Schmidhuber & Huber, 1990; Da Silva et al., 2012; Kupcsik et al., 2013; Deisenroth et al., 2014; Schaul et al., 2015; Zhu et al., 2017; Kober et al., 2012; Ghosh et al., 2018; Mankowitz et al., 2018; Pathak et al., 2018). Consequently, developing goal-based curricula to facilitate learning has also attracted considerable interest (Fabisch & Metzen, 2014; Florensa et al., 2017; Sukhbaatar et al., 2018; Srivastava et al., 2013). In hierarchical reinforcement learning, goal-conditional policies may enable agents to plan using subgoals, which abstracts the details involved in lower-level decisions (Oh et al., 2017; Vezhnevets et al., 2017; Kulkarni et al., 2016; Levy et al., 2017).
In a typical sparse-reward environment, an agent receives a non-zero reward only upon reaching a goal state. Besides being natural, this task formulation avoids the potentially difficult problem of reward shaping, which often biases the learning process towards suboptimal behavior (Ng et al., 1999). Unfortunately, sparse-reward environments remain particularly challenging for traditional reinforcement learning algorithms (Andrychowicz et al., 2017; Florensa et al., 2017). For example, consider an agent tasked with traveling between cities. In a sparse-reward formulation, if reaching a desired destination by chance is unlikely, a learning agent will rarely obtain reward signals. At the same time, it seems natural to expect that an agent will learn how to reach the cities it visited regardless of its desired destinations.
In this context, the capacity to exploit information about the degree to which an arbitrary goal has been achieved while another goal was intended is called hindsight. This capacity was recently introduced by Andrychowicz et al. (2017) to off-policy reinforcement learning algorithms that rely on experience replay (Lin, 1992). In earlier work, Karkus et al. (2016) introduced hindsight to policy search based on Bayesian optimization (Metzen et al., 2015).
1

Under review as a conference paper at ICLR 2019

In this paper, we demonstrate how hindsight can be introduced to policy gradient methods (Williams, 1986; 1992; Sutton et al., 1999a), generalizing this idea to a successful class of reinforcement learning algorithms (Peters & Schaal, 2008; Duan et al., 2016).
In contrast to previous work on hindsight, our approach relies on importance sampling (Bishop, 2013). In reinforcement learning, importance sampling has been traditionally employed in order to efficiently reuse information obtained by earlier policies during learning (Precup et al., 2000; Peshkin & Shelton, 2002; Jie & Abbeel, 2010; Thomas et al., 2015; Munos et al., 2016). In comparison, our approach attempts to efficiently learn about different goals using information obtained by the current policy for a specific goal. This approach leads to multiple formulations of a hindsight policy gradient that relate to well-known policy gradient results.
In comparison to conventional (goal-conditional) policy gradient estimators, our proposed estimators lead to remarkable sample efficiency on a diverse selection of sparse-reward environments.

2 PRELIMINARIES

We denote random variables by upper case letters and assignments to these variables by corresponding lower case letters. We let Val(X) denote the set of valid assignments to a random variable X. We also omit the subscript that typically relates a probability function to random variables when there is no risk of ambiguity. For instance, we may use p(x) to denote pX (x) and p(y) to denote pY (y).
Consider an agent that interacts with its environment in a sequence of episodes, each of which lasts for exactly T time steps. The agent receives a goal g  Val(G) at the beginning of each episode. At every time step t, the agent observes a state st  Val(St), receives a reward r(st, g)  R, and chooses an action at  Val(At). For simplicity of notation, suppose that Val(G), Val(St), and Val(At) are finite for every t.
In our setting, a goal-conditional policy defines a probability distribution over actions for every combination of state and goal. The same policy is used to make decisions at every time step.
Let  = s1, a1, s2, a2, . . . , sT -1, aT -1, sT denote a trajectory. We assume that the probability p( | g, ) of trajectory  given goal g and a policy parameterized by   Val() is given by

T -1
p( | g, ) = p(s1) p(at | st, g, )p(st+1 | st, at).
t=1

(1)

In contrast to a Markov decision process, this formulation allows the probability of a state transition given an action to change across time steps within an episode. More importantly, it implicitly states that the probability of a state transition given an action is independent of the goal pursued by the agent, which we denote by St+1  G | St, At. For every  , g, and , we also assume that p( | g, ) is non-zero and differentiable with respect to .
Assuming that G  , the expected return () of a policy parameterized by  is given by

TT

() = E r(St, G) |  = p(g) p( | g, ) r(st, g).

t=1

g

t=1

(2)

The action-value function is given by Qt (s, a, g) = E

T t

=t+1

r(St

, g) | St

= s, At

= a, g, 

,

the value function by Vt(s, g) = E Qt(s, At, g) | St = s, g,  , and the advantage function by At(s, a, g) = Qt (s, a, g) - Vt(s, g).

3 GOAL-CONDITIONAL POLICY GRADIENTS
This section presents results for goal-conditional policies that are analogous to well-known results for conventional policies (Peters & Schaal, 2008). They establish the foundation for the results presented in the next section. The corresponding proofs are included in Appendix A for completeness.

2

Under review as a conference paper at ICLR 2019

The objective of policy gradient methods is finding policy parameters that achieve maximum expected return. When combined with Monte Carlo techniques (Bishop, 2013), the following result allows pursuing this objective using gradient-based optimization.

Theorem 3.1 (Goal-conditional policy gradient). The gradient () of the expected return with respect to  is given by

T -1

T

() = p(g) p( | g, )  log p(at | st, g, )

r(st , g).

g

t=1

t =t+1

(3)

The following result allows employing a baseline to reduce the variance of the gradient estimator.

Theorem 3.2 (Goal-conditional policy gradient, baseline formulation). For every t, , and associated real-valued (baseline) function bt, the gradient () of the expected return with respect to  is given by

T -1

() = p(g) p( | g, )  log p(at | st, g, )

g

t=1

T
r(st , g) - bt (st, g) . (4)
t =t+1

Appendix A.7 presents the constant baselines that minimize the (elementwise) variance of the
corresponding estimator. However, such baselines are usually impractical to compute (or estimate),
and the variance of the estimator may be reduced further by a baseline function that depends on state and goal. Although generally suboptimal, it is typical to let the baseline function bt approximate the value function Vt (Greensmith et al., 2004).

Lastly, actor-critic methods may rely on the following result for goal-conditional policies.

Theorem 3.3 (Goal-conditional policy gradient, advantage formulation). The gradient () of the expected return with respect to  is given by

T -1

() = p(g) p( | g, )  log p(at | st, g, )At (st, at, g).

g

t=1

(5)

4 HINDSIGHT POLICY GRADIENTS

This section presents the novel ideas that introduce hindsight to policy gradient methods. The corresponding proofs can be found in Appendix B.

Suppose that the reward r(s, g) is known for every combination of state s and goal g, as in previous work on hindsight (Andrychowicz et al., 2017; Karkus et al., 2016). In that case, it is possible to evaluate a trajectory obtained while trying to achieve an original goal g for an alternative goal g. Using importance sampling, this information can be exploited using the following central result.

Theorem 4.1 (Every-decision hindsight policy gradient). For an arbitrary (original) goal g , the gradient () of the expected return with respect to  is given by

() =



p( | g , )
g

T -1

T

p(g)  log p(at | st, g, )

t=1

t =t+1

T -1 p(ak | sk, g, ) k=1 p(ak | sk, g , )

r(st , g).

(6)

In the formulation presented above, every reward is multiplied by the ratio between the likelihood of the corresponding trajectory under an alternative goal and the likelihood under the original goal (see Eq. 1). Intuitively, every reward should instead be multiplied by a likelihood ratio that only considers the corresponding trajectory up to the previous action. This intuition underlies the following important result, named after an analogous result for action-value functions by Precup et al. (2000).

Theorem 4.2 (Per-decision hindsight policy gradient). For an arbitrary (original) goal g , the gradient () of the expected return with respect to  is given by



() =



p( | g , )

g

T -1
p(g) 
t=1

log

p(at

|

st, g, )
t

T t -1

=t+1 k=1

p(ak p(ak

| sk, g, ) | sk, g , ) 

r(st

, g).

(7)

3

Under review as a conference paper at ICLR 2019

The following lemma allows introducing baselines to hindsight policy gradients (see App. B.4).

Lemma 4.1. For every g , t, , and associated real-valued (baseline) function bt ,



T -1
p( | g , ) p(g)  log p(at | st, g, )
g t=1

t p(ak | sk, g, ) k=1 p(ak | sk, g , )

bt(st, g) = 0.

(8)

Appendix B.7 presents the constant baselines that minimize the (elementwise) variance of the corresponding gradient estimator. By analogy with the conventional practice, we suggest letting the baseline function bt approximate the value function Vt instead.
Importantly, the choice of likelihood ratio in Lemma 4.1 is far from unique. However, besides leading to straightforward estimation, it also underlies the advantage formulation presented below.
Theorem 4.3 (Hindsight policy gradient, advantage formulation). For an arbitrary (original) goal g , the gradient () of the expected return with respect to  is given by

() =

T -1
p( | g , ) p(g)  log p(at | st, g, )
 g t=1

t p(ak | sk, g, ) k=1 p(ak | sk, g , )

At (st, at, g).

(9)

Fortunately, the following result allows approximating the advantage under a goal using a state transition collected while pursuing another goal (see App. D.4).

Theorem 4.4. For every t and , the advantage function At is given by

At (s, a, g) = E r(St+1, g) + Vt+1(St+1, g) - Vt(s, g) | St = s, At = a .

(10)

5 HINDSIGHT GRADIENT ESTIMATORS

This section details gradient estimation based on the results presented in the previous section. The corresponding proofs can be found in Appendix C.

Consider a dataset (batch) D = {( (i), g(i))}iN=1 where each trajectory  (i) is obtained using a policy parameterized by  in an attempt to achieve a goal g(i) chosen by the environment.

The following result points to a straightforward estimator based on Theorem 4.2. Theorem 5.1. The per-decision hindsight policy gradient estimator, given by



1N N
i=1

g

T -1
p(g) 
t=1

log p(At(i)

|

St(i), G(i)

=

g, )
t

T =t+1

t -1

k=1

p(A(ki) | Sk(i), G(i) = p(Ak(i) | Sk(i), G(i),

g, ) )



r(St(i),

g),

(11)

is a consistent and unbiased estimator of the gradient () of the expected return.

In preliminary experiments, we found that this estimator leads to unstable learning progress, which is probably due to its potential high variance. The following result, inspired by weighted importance sampling (Bishop, 2013), represents our attempt to trade variance for bias.
Theorem 5.2. The weighted per-decision hindsight policy gradient estimator, given by

N T -1

T

p(g)  log p(A(ti) | St(i), G(i) = g, )

i=1 g

t=1

t =t+1

t -1 p(A(ki)|Sk(i),G(i)=g,) k=1 p(Ak(i)|Sk(i),G(i),)

r(St(i), g) ,

N t -1 p(Ak(j)|Sk(j),G(j)=g,)

j=1

k=1 p(Ak(j)|Sk(j),G(j),)

is a consistent estimator of the gradient () of the expected return.

(12)

In simple terms, the likelihood ratio for every combination of trajectory, (alternative) goal, and time step is normalized across trajectories by this estimator. In Appendix C.3, we present a result that enables the corresponding consistency-preserving weighted baseline.

4

Under review as a conference paper at ICLR 2019
Consider a set G(i) = {g  Val(G) | exists a t such that r(s(ti), g) = 0} composed of so-called active goals during the i-th episode. The feasibility of the proposed estimators relies on the fact that only active goals correspond to non-zero terms inside the expectation over goals in Expressions 11 and 12. In many natural sparse-reward environments, active goals will correspond directly to states visited during episodes (for instance, the cities visited while trying to reach other cities), which enables computing said expectation exactly when the goal distribution is known.
The proposed estimators have remarkable properties that differentiate them from previous (weighted) importance sampling estimators for off-policy learning. For instance, although a trajectory is often more likely under the original goal than under an alternative goal, in policies with strong optimal substructure, a high probability of a trajectory between the state a and the goal (state) c that goes through the state b may naturally allow for a high probability of the corresponding (sub)trajectory between the state a and the goal (state) b. In other cases, the (unnormalized) likelihood ratios may become very small for some (alternative) goals after a few time steps across all trajectories. After normalization, in the worst case, this may even lead to equivalent ratios for such goals for a given time step across all trajectories. In any case, it is important to note that only likelihood ratios associated to active goals for a given episode will affect the gradient estimate. Additionally, an original goal will always have (unnormalized) likelihood ratios equal to one for the corresponding episode.
Under mild additional assumptions, the proposed estimators also allow using a dataset containing goals chosen arbitrarily (instead of goals drawn from the goal distribution). Although this feature is not required by our experiments, we believe that it may be useful to circumvent catastrophic forgetting during curriculum learning (McCloskey & Cohen, 1989; Kirkpatrick et al., 2017).
6 EXPERIMENTS
This section reports results of an empirical comparison between goal-conditional policy gradient estimators and hindsight policy gradient estimators.1 Because there are no well-established sparsereward environments intended to test agents under multiple goals, this comparison focuses on our own selection of environments. These environments are diverse in terms of stochasticity, state space dimensionality and size, relationship between goals and states, and number of actions. In every one of these environments, the agent receives the remaining number of time steps plus one as a reward for reaching the goal state, which also ends the episode. In every other situation, the agent receives no reward.

Figure 1: Four rooms.

Figure 2: Ms. Pac-man.

Figure 3: FetchPush.

Importantly, the weighted per-decision hindsight policy gradient estimator used in our experiments (HPG) does not precisely correspond to Expression 12. Firstly, the original estimator requires a constant number of time steps T , which would often require the agent to act after the end of an episode in the environments that we consider. Secondly, although it is feasible to compute Expression 12 exactly when the goal distribution is known (as explained in Sec. 5), we sometimes subsample the sets of active goals per episode. Furthermore, when including a baseline that approximates the value function, we again consider only active goals, which by itself generally results in an inconsistent
1An open-source implementation of these estimators is available on [omitted during review process].

5

Under review as a conference paper at ICLR 2019

estimator (HPG+B). As will become evident in the following sections, these compromised estimators still lead to remarkable sample efficiency.
We assess sample efficiency through learning curves and average performance scores, which are obtained as follows. After collecting a number of batches (composed of trajectories and goals), each of which enables one step of gradient ascent, an agent undergoes evaluation. During evaluation, the agent interacts with the environment for a number of episodes, selecting actions with maximum probability according to its policy. A learning curve shows the average return obtained during each evaluation step, averaged across multiple runs (independent learning procedures). The curves presented in this text also include a 95% bootstrapped confidence interval. The average performance is given by the average return across evaluation steps, averaged across runs. During both training and evaluation, goals are drawn uniformly at random. Note that there is no held-out set of goals for evaluation, since we are interested in evaluating sample efficiency instead of generalization.
For every combination of environment and batch size, grid search is used to select hyperparameters for each estimator according to average performance scores (after the corresponding standard deviation across runs is subtracted, as suggested by Duan et al. (2016)). Definitive results are obtained by using the best hyperparameters found for each estimator in additional runs. In this section, we discuss definitive results for small (2) and medium (16) batch sizes.
More details about our experiments can be found in Appendices E.1 and E.2. Appendix E.3 contains unabridged results and a supplementary empirical study of likelihood ratios (Appendix E.3.6).
6.1 BIT FLIPPING ENVIRONMENTS
In a bit flipping environment, the agent starts every episode in the same state (0, represented by k bits), and its goal is to reach a randomly chosen state. The actions allow the agent to toggle (flip) each bit individually. The maximum number of time steps is k + 1. Despite its apparent simplicity, this environment is an ideal testbed for reinforcement learning algorithms intended to deal with sparse rewards, since obtaining a reward by chance is unlikely even for a relatively small k. Andrychowicz et al. (2017) employed a similar environment to evaluate their hindsight approach.
Figure 4 presents the learning curves for k = 8. Goal-conditional policy gradient estimators with and without an approximate value-function baseline (GCPG+B and GCPG, respectively) obtain excellent policies and lead to comparable sample efficiency. HPG+B obtains excellent policies more than 400 batches earlier than these estimators, but its policies degrade upon additional training. Recall that HPG+B focuses solely on active goals where the theory prescribes an expectation over all goals. Accordingly, we hypothesize that the observed instability is caused by a combination of the changes in the state visitation distribution during training with the difficulty of fitting the baseline. In comparison, HPG obtains excellent policies as early as HPG+B, but its policies remain remarkably stable upon additional training.

average return average return

5
4
3
2
1 HPG GCPG HPG+B
0 GCPG+B 20 40 60 80 100 evaluation step
Figure 4: Bit flipping (k = 8, batch size 16).

8
6
4
2 HPG GCPG HPG+B GCPG+B
0 20 40 60 80 100 evaluation step
Figure 5: Bit flipping (k = 16, batch size 16).

The learning curves for k = 16 are presented in Figure 5. Clearly, both GCPG and GCPG+B are unable to obtain policies that perform better than chance, which is explained by the fact that they

6

Under review as a conference paper at ICLR 2019

rarely incorporate reward signals during training. Confirming the importance of hindsight, HPG leads to stable and sample efficient learning. Although HPG+B also obtains excellent policies, they deteriorate upon additional training.
Similar results can be observed for a small batch size (see App. E.3.3). The average performance results documented in Appendix E.3.5 confirm that HPG leads to remarkable sample efficiency. Importantly, Appendices E.3.1 and E.3.2 present hyperparameter sensitivity graphs suggesting that HPG is less sensitive to hyperparameter settings than the other estimators. The same two appendices also document an ablation study where the likelihood ratios are removed from HPG, which notably promotes increased hyperparameter sensitivity. This study confirms the usefulness of the correction prescribed by importance sampling.
6.2 GRID WORLD ENVIRONMENTS
In the grid world environments that we consider, the agent starts every episode in a (possibly random) position on an 11 × 11 grid, and its goal is to reach a randomly chosen (non-initial) position. Some of the positions on the grid may contain impassable obstacles (walls). The actions allow the agent to move in the four cardinal directions. Moving towards walls causes the agent to remain in its current position. A state or goal is represented by a pair of integers between 0 and 10. The maximum number of time steps is 32. In the empty room environment, the agent starts every episode in the upper left corner of the grid, and there are no walls. In the four rooms environment (Sutton et al., 1999b), the agent starts every episode in one of the four corners of the grid (see Fig. 1). There are walls that partition the grid into four rooms, such that each room provides access to two other rooms through single openings (doors). With probability 0.2, the action chosen by the agent is ignored and replaced by a random action.
Figure 6 shows the learning curves for the empty room environment. Clearly, every estimator obtains excellent policies, although HPG and HPG+B improve sample efficiency by at least 200 batches. The learning curves for the four rooms environment are presented in Figure 7. In this surprisingly challenging environment, every estimator obtains unsatisfactory policies. However, it is still clear that HPG and HPG+B improve sample efficiency. In contrast to the experiments presented in the previous section, HPG+B does not give rise to instability, which we attribute to easier value function estimation. Similar results can be observed for a small batch size (see App. E.3.3). HPG achieves the best average performance in every grid world experiment except for a single case, where the best average performance is achieved by HPG+B (see App. E.3.5). The hyperparameter sensitivity graphs presented in Appendices E.3.1 and E.3.2 once again suggest that HPG is less sensitive to hyperparameter choices, and that ignoring likelihood ratios promotes increased sensitivity (at least in the four rooms environment).

average return average return

20
15
10
5 HPG GCPG HPG+B GCPG+B
0 20 40 60 80 100 evaluation step
Figure 6: Empty room (batch size 16).

10
8
6
4 HPG
2 GCPG HPG+B GCPG+B
20 40 60 80 100 evaluation step
Figure 7: Four rooms (batch size 16).

7

Under review as a conference paper at ICLR 2019

6.3 MS. PAC-MAN ENVIRONMENT
The Ms. Pac-man environment is a variant of the homonymous game for ATARI 2600 (see Fig. 2). The agent starts every episode close to the center of the map, and its goal is to reach a randomly chosen (non-initial) position on a 14 × 19 grid defined on the game screen. The actions allow the agent to move in the four cardinal directions for 13 game ticks. A state is represented by the result of preprocessing a sequence of game screens (images) as described in Appendix E.1. A goal is represented by a pair of integers. The maximum number of time steps is 28, although an episode will also end if the agent is captured by an enemy. In comparison to the grid world environments considered in the previous section, this environment is additionally challenging due to its high-dimensional states and the presence of enemies.
Figure 8 presents the learning curves for a medium batch size. Approximate value function baselines are excluded from this experiment due to the significant cost of systematic hyperparameter search. Although HPG obtains better policies during early training, GCPG obtains better final policies. However, for such a medium batch size, only 3 active goals per episode (out of potentially 28) are subsampled for HPG. Although this harsh subsampling brings computational efficiency, it also appears to handicap the estimator. This hypothesis is supported by the fact that HPG outperforms GCPG for a small batch size, when all active goals are used (see Apps. E.3.3 and E.3.5). Policies obtained using each estimator are illustrated by videos included on the project website.2

average return average return

10
8
6
4
2 HPG GCPG
0 20 40 60 80 100 evaluation step
Figure 8: Ms. Pac-man (batch size 16).

18
16
14
12
10
8
6
4 HPG GCPG
2 20 40 60 80 100 evaluation step
Figure 9: FetchPush (batch size 16).

6.4 FETCHPUSH ENVIRONMENT
The FetchPush environment is a variant of the environment recently proposed by Plappert et al. (2018) to assess goal-conditional policy learning algorithms in a challenging task of practical interest (see Fig. 3). In a simulation, a robotic arm with seven degrees of freedom is required to push a randomly placed object (block) towards a randomly chosen position. The arm starts every episode in the same configuration. In contrast to the original environment, the actions in our variant allow increasing the desired velocity of the gripper along each of two orthogonal directions by ±0.1 or ±1, leading to a total of eight actions. A state is represented by a 28-dimensional real vector that contains the following information: positions of the gripper and block; rotational and positional velocities of the gripper and block; relative position of the block with respect to the gripper; state of the gripper; and current desired velocity of the gripper along each direction. A goal is represented by three coordinates. The maximum number of time steps is 50.
Figure 9 presents the learning curves for a medium batch size. HPG obtains good policies after a reasonable number of batches, in sharp contrast to GCPG. For such a medium batch size, only 3 active goals per episode (out of potentially 50) are subsampled for HPG, showing that subsampling is a viable alternative to reduce the computational cost of hindsight. Similar results are observed for a small batch size, when all active goals are used (see Apps. E.3.3 and E.3.5). Policies obtained using each estimator are illustrated by videos included on the project website.
2These videos are available here during the review process.
8

Under review as a conference paper at ICLR 2019
7 CONCLUSION
We introduced techniques that enable learning goal-conditional policies using hindsight. In this context, hindsight refers to the capacity to exploit information about the degree to which an arbitrary goal has been achieved while another goal was intended. Prior to our work, hindsight has been limited to off-policy reinforcement learning algorithms that rely on experience replay (Andrychowicz et al., 2017) and policy search based on Bayesian optimization (Karkus et al., 2016).
In addition to the fundamental hindsight policy gradient, our technical results include its baseline and advantage formulations. These results are based on a self-contained goal-conditional policy framework that is also introduced in this text. Besides the straightforward estimator built upon the per-decision hindsight policy gradient, we also presented a consistent estimator inspired by weighted importance sampling, together with the corresponding baseline formulation. A variant of this estimator leads to remarkable comparative sample efficiency on a diverse selection of sparsereward environments, especially in cases where direct reward signals are extremely difficult to obtain. This crucial feature allows natural task formulations that require just trivial reward shaping.
The main drawback of hindsight policy gradient estimators appears to be their computational cost, which is directly related to the number of active goals in a batch. This issue may be mitigated by subsampling active goals, which generally leads to inconsistent estimators. Fortunately, our experiments suggest that this is a viable alternative. Note that the success of hindsight experience replay also depends on an active goal subsampling heuristic (Andrychowicz et al., 2017, Sec. 4.5). The inconsistent hindsight policy gradient estimator with a value-function baseline employed in our experiments sometimes leads to unstable learning, which is likely related to its unprincipled focus on active goals. This behavior requires more investigation. Further experiments are also required to evaluate hindsight on dense-reward environments.
There are many possibilities for future work besides integrating hindsight policy gradients into systems that rely on goal-conditional policies: deriving additional estimators; implementing and evaluating hindsight (advantage) actor-critic methods; assessing whether hindsight policy gradients can successfully circumvent catastrophic forgetting during curriculum learning of goal-conditional policies; approximating the reward function to reduce required supervision; employing hindsight experience replay to train value-function baselines; analysing the variance of the proposed estimators; studying the impact of active goal subsampling; evaluating every technique on continuous action spaces; and comparing with techniques based on hindsight experience replay.
REFERENCES
M. Andrychowicz, F. Wolski, A. Ray, J. Schneider, R. Fong, P. Welinder, B. McGrew, J. Tobin, P. Abbeel, and W. Zaremba. Hindsight experience replay. In Advances in Neural Information Processing Systems, pp. 5048­5058, 2017.
M. G. Bellemare, Y. Naddaf, J. Veness, and M. Bowling. The arcade learning environment: An evaluation platform for general agents. Journal of Artificial Intelligence Research, 47:253­279, jun 2013.
C. M. Bishop. Pattern Recognition and Machine Learning. Information science and statistics. Springer, 2013. ISBN 9788132209065.
B. C. Da Silva, G. Konidaris, and A. G. Barto. Learning parameterized skills. In Proceedings of International Conference of Machine Learning, 2012.
M. P. Deisenroth, P. Englert, J. Peters, and D. Fox. Multi-task policy search for robotics. In IEEE International Conference on Robotics and Automation, 2014, pp. 3876­3881, 2014.
Y. Duan, X. Chen, R. Houthooft, J. Schulman, and P. Abbeel. Benchmarking deep reinforcement learning for continuous control. In Proceedings of International Conference on Machine Learning, pp. 1329­1338, 2016.
A. Fabisch and J. H. Metzen. Active contextual policy search. The Journal of Machine Learning Research, 15(1):3371­3399, 2014.
9

Under review as a conference paper at ICLR 2019
C. Florensa, D. Held, M. Wulfmeier, M. Zhang, and P. Abbeel. Reverse curriculum generation for reinforcement learning. In Proceedings of the 1st Annual Conference on Robot Learning, pp. 482­495, 13­15 Nov 2017.
D. Ghosh, A. Singh, A. Rajeswaran, V. Kumar, and S. Levine. Divide-and-conquer reinforcement learning. In International Conference on Learning Representations, 2018.
X. Glorot and Y. Bengio. Understanding the difficulty of training deep feedforward neural networks. In Proceedings of the thirteenth international conference on artificial intelligence and statistics, pp. 249­256, 2010.
E. Greensmith, P. L. Bartlett, and J. Baxter. Variance reduction techniques for gradient estimates in reinforcement learning. Journal of Machine Learning Research, 5(Nov):1471­1530, 2004.
T. Jie and P. Abbeel. On a connection between importance sampling and the likelihood ratio policy gradient. In Advances in Neural Information Processing Systems, pp. 1000­1008, 2010.
P. Karkus, A. Kupcsik, D. Hsu, and W. S. Lee. Factored contextual policy search with bayesian optimization. arXiv preprint arXiv:1612.01746, 2016.
D. P. Kingma and J. Ba. Adam: A method for stochastic optimization. In Proceedings of the 3rd International Conference on Learning Representations, 2014.
J. Kirkpatrick, R. Pascanu, N. Rabinowitz, J. Veness, G. Desjardins, A. A. Rusu, K. Milan, J. Quan, T. Ramalho, A. Grabska-Barwinska, et al. Overcoming catastrophic forgetting in neural networks. Proceedings of the National Academy of Sciences, 114(13):3521­3526, 2017.
J. Kober, A. Wilhelm, E. Oztop, and J. Peters. Reinforcement learning to adjust parametrized motor primitives to new situations. Autonomous Robots, 33(4):361­379, 2012.
T. D. Kulkarni, K. Narasimhan, A. Saeedi, and J. Tenenbaum. Hierarchical deep reinforcement learning: Integrating temporal abstraction and intrinsic motivation. In Advances in Neural Information Processing Systems, pp. 3675­3683, 2016.
A. G. Kupcsik, M. P. Deisenroth, J. Peters, and G. Neumann. Data-efficient generalization of robot skills with contextual policy search. In Proceedings of the 27th AAAI Conference on Artificial Intelligence, AAAI 2013, pp. 1401­1407, 2013.
A. Levy, R. Platt, and K. Saenko. Hierarchical actor-critic. arXiv preprint arXiv:1712.00948, 2017.
L. Lin. Self-improving reactive agents based on reinforcement learning, planning and teaching. Machine learning, 8(3/4):69­97, 1992.
D. J. Mankowitz, A. Zídek, A. Barreto, D. Horgan, M. Hessel, J. Quan, J. Oh, H. van Hasselt, D. Silver, and T. Schaul. Unicorn: Continual learning with a universal, off-policy agent. arXiv preprint arXiv:1802.08294, 2018.
M. McCloskey and N. J. Cohen. Catastrophic interference in connectionist networks: The sequential learning problem. Psychology of Learning and Motivation-Advances in Research and Theory, 24 (C):109­165, 1989.
J. H. Metzen, A. Fabisch, and J. Hansen. Bayesian optimization for contextual policy search. In Proceedings of the Second Machine Learning in Planning and Control of Robot Motion Workshop., Hamburg, 2015.
V. Mnih, K. Kavukcuoglu, D. Silver, A. A. Rusu, J. Veness, M. G. Bellemare, A. Graves, M. Riedmiller, A. K. Fidjeland, G. Ostrovski, et al. Human-level control through deep reinforcement learning. Nature, 518(7540):529, 2015.
R. Munos, T. Stepleton, A. Harutyunyan, and M. Bellemare. Safe and efficient off-policy reinforcement learning. In Advances in Neural Information Processing Systems, pp. 1054­1062, 2016.
10

Under review as a conference paper at ICLR 2019
A. Y. Ng, D. Harada, and S. Russell. Policy invariance under reward transformations: Theory and application to reward shaping. In International Conference on Machine Learning, volume 99, pp. 278­287, 1999.
J. Oh, S. Singh, H. Lee, and P. Kohli. Zero-shot task generalization with multi-task deep reinforcement learning. In Proceedings of the 34th International Conference on Machine Learning, 06­11 Aug 2017.
D. Pathak, P. Mahmoudieh, M. Luo, P. Agrawal, D. Chen, F. Shentu, E. Shelhamer, J. Malik, A. A. Efros, and T. Darrell. Zero-shot visual imitation. In International Conference on Learning Representations, 2018.
L. Peshkin and C. R. Shelton. Learning from scarce experience. In Proceedings of the Nineteenth International Conference on Machine Learning, pp. 498­505, 2002.
J. Peters and S. Schaal. Reinforcement learning of motor skills with policy gradients. Neural networks, 21(4):682­697, 2008.
M. Plappert, M. Andrychowicz, A. Ray, B. McGrew, B. Baker, G. Powell, J. Schneider, J. Tobin, M. Chociej, P. Welinder, et al. Multi-goal reinforcement learning: Challenging robotics environments and request for research. arXiv preprint arXiv:1802.09464, 2018.
D. Precup, R. S. Sutton, and S. P. Singh. Eligibility traces for off-policy policy evaluation. In International Conference on Machine Learning, pp. 759­766, 2000.
T. Schaul, D. Horgan, K. Gregor, and D. Silver. Universal value function approximators. In Proceedings of the International Conference on Machine Learning, pp. 1312­1320, 2015.
J. Schmidhuber and R. Huber. Learning to Generate Focus Trajectories for Attentive Vision. Institut für Informatik, 1990.
P. Sen and J. Singer. Large Sample Methods in Statistics: An Introduction with Applications. Chapman & Hall/CRC Texts in Statistical Science. Taylor & Francis, 1994. ISBN 9780412042218.
R. K. Srivastava, B. R. Steunebrink, and J. Schmidhuber. First experiments with PowerPlay. Neural Networks, 41(0):130 ­ 136, 2013. Special Issue on Autonomous Learning.
S. Sukhbaatar, Z. Lin, I. Kostrikov, G. Synnaeve, A. Szlam, and R. Fergus. Intrinsic motivation and automatic curricula via asymmetric self-play. In International Conference on Learning Representations, 2018.
R. S. Sutton and A. G. Barto. Reinforcement Learning: An Introduction. Bradford Book, 1998. ISBN 9780262193986.
R. S. Sutton, D. A. McAllester, S. P. Singh, and Y. Mansour. Policy gradient methods for reinforcement learning with function approximation. In Advances in Neural Information Processing Systems 12, pp. 1057­1063, 1999a.
R. S. Sutton, D. Precup, and S. Singh. Between MDPs and semi-MDPs: A framework for temporal abstraction in reinforcement learning. Artificial intelligence, 112(1-2):181­211, 1999b.
P. Thomas. Safe reinforcement learning. PhD thesis, University of Massachusetts Amherst, 2015.
P. Thomas, G. Theocharous, and M. Ghavamzadeh. High confidence policy improvement. In International Conference on Machine Learning, pp. 2380­2388, 2015.
A. S. Vezhnevets, S. Osindero, T. Schaul, N. Heess, M. Jaderberg, D. Silver, and K. Kavukcuoglu. FeUdal networks for hierarchical reinforcement learning. In Proceedings of the 34th International Conference on Machine Learning, pp. 3540­3549, 06­11 Aug 2017.
R. J. Williams. Reinforcement-learning in connectionist networks: A mathematical analysis. Technical Report 8605, Institute for Cognitive Science, University of California, San Diego, 1986.
R. J. Williams. Simple statistical gradient-following algorithms for connectionist reinforcement learning. Machine learning, 8(3-4):229­256, 1992.
11

Under review as a conference paper at ICLR 2019 Y. Zhu, R. Mottaghi, E. Kolve, J. J. Lim, A. Gupta, L. Fei-Fei, and A. Farhadi. Target-driven visual
navigation in indoor scenes using deep reinforcement learning. In IEEE International Conference on Robotics and Automation, pp. 3357­3364, 2017.
12

Under review as a conference paper at ICLR 2019

A GOAL-CONDITIONAL POLICY GRADIENTS

This appendix contains proofs related to the results presented in Section 3: Theorem 3.1 (App. A.2), Theorem 3.2 (App. A.4), and Theorem 3.3 (App. A.6). Appendix A.7 presents optimal constant baselines for goal-conditional policies. The remaining subsections contain auxiliary results.

A.1 THEOREM A.1

Theorem A.1. The gradient () of the expected return with respect to  is given by

T -1

() = p(g) p( | g, )

 log p(at | st, g, )

g

t=1

T
r(st, g) .
t=1

(13)

Proof. The partial derivative ()/j of the expected return () with respect to j is given by

 () =
j

g

p(g)


 p(
j

|

g, )

T
r(st, g).
t=1

(14)

The likelihood-ratio trick allows rewriting the previous equation as

 () =
j

g

p(g)



p(

|

 g, )
j

log p(

|

g, )

T
r(st, g).
t=1

(15)

Note that

T -1

T -1

log p( | g, ) = log p(s1) + log p(at | st, g, ) + log p(st+1 | st, at).

t=1 t=1

(16)

Therefore,

 T -1 

() = j

p(g) p( | g, )
g

t=1 j log p(at | st, g, )

T
r(st, g) .
t=1

(17)

A.2 THEOREM 3.1

Theorem 3.1 (Goal-conditional policy gradient). The gradient () of the expected return with respect to  is given by

T -1

T

() = p(g) p( | g, )  log p(at | st, g, )

r(st , g).

g

t=1

t =t+1

(3)

Proof. Starting from Eq. 17, the partial derivative ()/j of () with respect to j is given by

 () =
j

g

p(g | )



p(

|

g, )

T t=1

T -1
r(st, g)
t =1

 j

log p(at

| st , g, ).

(18)

The previous equation can be rewritten as

 T T -1



j

()

=

t=1

t

E
=1

r(St, G) j log p(At

| St , G, ) | 

.

(19)

13

Under review as a conference paper at ICLR 2019

Let c denote an expectation inside Eq. 19 for t  t. In that case, At  St | St , G, , and so



c=
st st

g at p(at | st , g, )p(st, st , g | )r(st, g) j log p(at | st , g, ).

(20)

Reversing the likelihood-ratio trick,



c=
st st

g

p(st,

st

,

g

|

)r(st,

g) j

at

p(at

| st , g, ) = 0.

(21)

Therefore, the terms where t  t can be dismissed from Eq. 19, leading to

 T t-1 

j () = E

t=1

r(St, G)
t

=1

j

log

p(At

| St , G, ) | 

.

(22)

The previous equation can be conveniently rewritten as

 j () = E

T -1 t=1

 j

log p(At

|

St, G, )
t

T
r(St
=t+1

, G)

|



.

(23)

A.3 LEMMA A.1

Lemma A.1. For every j, t, , and associated real-valued (baseline) function bt,

T -1
E
t=1

 j

log p(At

|

St, G, )bt(St, G)

|



= 0.

Proof. Letting c denote an expectation inside Eq. 24,

c=
st

g

at

p(at

|

st, g, )p(st, g

|

 )
j

log p(at

|

st, g, )bt(st, g).

Reversing the likelihood-ratio trick,

c=
st

g

p(st,

g

|

)bt (st ,

g)

 j

at

p(at | st, g, ) = 0.

(24) (25) (26)

A.4 THEOREM 3.2

Theorem 3.2 (Goal-conditional policy gradient, baseline formulation). For every t, , and associated real-valued (baseline) function bt , the gradient () of the expected return with respect to  is given by

T -1

() = p(g) p( | g, )  log p(at | st, g, )

g

t=1

T
r(st , g) - bt (st, g) . (4)
t =t+1

Proof. The result is obtained by subtracting Eq. 24 from Eq. 23. Importantly, for every combination of  and t, it would also be possible to have a distinct baseline function for each parameter in .

14

Under review as a conference paper at ICLR 2019

A.5 LEMMA A.2

Lemma A.2. The gradient () of the expected return with respect to  is given by

T -1

() = p(g) p( | g, )  log p(at | st, g, )Qt (st, at, g).

g

t=1

(27)

Proof. Starting from Eq. 23 and rearranging terms,

 T -1

() =

j

t=1 g

T

st

at

p(st, at, g | ) j

log p(at

| st, g, )
st+1:T

p(st+1:T

| st, at, g, )
t

r(st
=t+1

, g).

(28)

By the definition of action-value function,

 j () = E

T -1 t=1

 j

log p(At

|

St, G, )Qt(St, At, G)

|



.

(29)

A.6 THEOREM 3.3

Theorem 3.3 (Goal-conditional policy gradient, advantage formulation). The gradient () of the expected return with respect to  is given by

T -1

() = p(g) p( | g, )  log p(at | st, g, )At (st, at, g).

g

t=1

(5)

Proof. The result is obtained by choosing bt = Vt and subtracting Eq. 24 from Eq. 29.

A.7 THEOREM A.2

For arbitrary j and , consider the following definitions of f and h.

f ( ,

g)

=

T -1 t=1

 j

log

p(at

|

st,

g,

)

t

T =t+1

r(st

,

g),

h( ,

g)

=

T -1 t=1

 j

log

p(at

|

st,

g,

).

(30) (31)

For every bj  R, using Theorem 3.1 and the fact that E [h(T , G) | ] = 0 by Lemma A.1,

 j

()

=

E

[f

(T

,

G)

|

]

=

E

[f

(T

,

G)

-

bj h(T

,

G)

|

]

.

(32)

Theorem A.2. Assuming Var [h(T , G) | ] > 0, the (optimal constant baseline) bj that minimizes Var [f (T , G) - bjh(T , G) | ] is given by

bj

=

E [f (T , G)h(T , G) | E [h(T , G)2 | ]

] .

(33)

Proof. The result is an application of Lemma D.4.

15

Under review as a conference paper at ICLR 2019

B HINDSIGHT POLICY GRADIENTS

This appendix contains proofs related to the results presented in Section 4: Theorem 4.1 (App. B.1), Theorem 4.2 (App. B.2), Lemma 4.1 (App. B.3), Theorem B.1 (App. B.4), and Theorem 4.3 (App. B.6). Appendix B.7 presents optimal constant baselines for hindsight policy gradients. Appendix B.5 contains an auxiliary result.

B.1 THEOREM 4.1

The following theorem relies on importance sampling, a traditional technique used to obtain estimates related to a random variable X  p using samples from an arbitrary positive distribution q. This
technique relies on the following equalities:

q(x) p(X)

Ep(X) [f (X)] =

p(x)f (x) =

q(x) p(x)f (x) = Eq(X)

f (X) q(X )

.

xx

(34)

Theorem 4.1 (Every-decision hindsight policy gradient). For an arbitrary (original) goal g , the gradient () of the expected return with respect to  is given by

() =



p( | g , )
g

T -1

T

p(g)  log p(at | st, g, )

t=1

t =t+1

T -1 p(ak | sk, g, ) k=1 p(ak | sk, g , )

r(st , g).

(6)

Proof. Starting from Theorem 3.1, importance sampling allows rewriting the partial derivative ()/j as

 () =
j

g

p(g)


p( p(

| |

g g

, ) p(
, )

|

T -1
g, )
t=1

 j

log p(at

|

st, g, )
t

T
r(st
=t+1

, g).

(35)

Using Equation 1,

 () =
j

p(g)
g

p( | g , )

T -1 p(ak | sk, g, ) k=1 p(ak | sk, g , )

T -1 t=1

 j

log p(at

|

st, g, )
t

T
r(st
=t+1

, g).

(36)

B.2 THEOREM 4.2

Theorem 4.2 (Per-decision hindsight policy gradient). For an arbitrary (original) goal g , the gradient () of the expected return with respect to  is given by



() =



p( | g , )

g

T -1
p(g) 
t=1

log

p(at

|

st, g, )
t

T t -1

=t+1 k=1

p(ak p(ak

| sk, g, ) | sk, g , ) 

r(st

, g).

(7)

Proof. Starting from Eq. 36, the partial derivative ()/j can be rewritten as

 () =
j

g

T -1 T
p(g)
t=1 t =t+1



p( | g , )

T -1 p(ak | sk, g, ) k=1 p(ak | sk, g , )

 j

log p(at

|

st, g, )r(st

, g).

(37)

If we split every trajectory into states and actions before and after t , then ()/j is given by

g

T -1
p(g)
t=1 t

T =t+1 s1:t

-1 a1:t

p(s1:t
-1

-1, a1:t

-1

|g


t

-1

, ) 

k=1

 p(ak | sk, g, )
 p(ak | sk, g , )

 j

log p(at

| st, g, )z,

(38)

16

Under review as a conference paper at ICLR 2019

where z is defined by

z = p(st :T , at :T -1 | s1:t -1, a1:t -1, g , )
st :T at :T -1

T -1 p(ak | sk, g, ) k=t p(ak | sk, g , )

r(st , g).

(39)

Using Lemma D.2 and canceling terms,

T -1

z=

p(st | st -1, at -1)

p(ak | sk, g, )p(sk+1 | sk, ak) r(st , g).

st :T at :T -1

k=t

(40)

Using Lemma D.2 once again,
z = p(st :T , at :T -1 | s1:t -1, a1:t -1, g, )r(st , g).
st :T at :T -1

(41)

Using the fact that St  G | S1:t -1, A1:t -1, ,
z = r(st , g)p(st | s1:t -1, a1:t -1, g, ) = r(st , g)p(st | s1:t -1, a1:t -1, g , ). (42)
st st

Substituting z into Expression 38 and returning to an expectation over trajectories,



 () =
j



p( | g , )

g

T -1
p(g)
t=1

 j

log p(at

|

st, g, )
t

T t -1

=t+1 k=1

p(ak p(ak

| |

sk, g, ) sk, g , )



r(st

, g).

(43)

B.3 LEMMA 4.1

Lemma 4.1. For every g , t, , and associated real-valued (baseline) function bt ,



T -1
p( | g , ) p(g)  log p(at | st, g, )
g t=1

t p(ak | sk, g, ) k=1 p(ak | sk, g , )

bt(st, g) = 0.

(8)

Proof. Let c denote the j-th element of the vector in the left-hand side of Eq. 8, such that

c=

g

T -1
p(g) E
t=1

 j

log p(At

|

St, g, )

t p(Ak | Sk, g, ) k=1 p(Ak | Sk, g , )

bt (St, g) | g , 

.

(44)

Using Lemma D.1 and writing the expectations explicitly,

c=

g

T -1
p(g)
t=1

s1:t

a1:t

p(s1:t, a1:t

|

g

 , )
j

log p(at

|

st

,

g,

)

p(s1:t, a1:t p(s1:t, a1:t

| |

g, ) g , )

bt

(st,

g).

(45)

Canceling terms, using Lemma D.1 once again, and reversing the likelihood-ratio trick,

c=

g

T -1
p(g)
t=1

s1:t

a1:t

 j p(at

|

st, g, )

t-1
p(s1) p(ak | sk, g, )p(sk+1 | sk, ak)
k=1

bt(st, g).

(46)

Pushing constants outside the summation over actions at time step t,

c=

T -1
p(g)
g t=1 s1:t a1:t-1

t-1
p(s1) p(ak | sk, g, )p(sk+1 | sk, ak)
k=1

bt

(st

,

g)

 j

p(at | st, g, ) = 0.
at

(47)

17

Under review as a conference paper at ICLR 2019

B.4 THEOREM B.1

Theorem B.1 (Hindsight policy gradient, baseline formulation). For every g , t, , and associated real-valued (baseline) function bt , the gradient () of the expected return with respect to  is given by

T -1
() = p( | g , ) p(g)  log p(at | st, g, )z,
 g t=1

(48)

where





z

=


t

T =t+1

t -1

k=1

p(ak p(ak

| |

sk, g, ) sk, g , )



r(st

,

g)

-

t p(ak | sk, g, ) k=1 p(ak | sk, g , )

bt (st, g).

(49)

Proof. The result is obtained by subtracting Eq. 8 from Eq. 7. Importantly, for every combination of  and t, it would also be possible to have a distinct baseline function for each parameter in .

B.5 LEMMA B.1

Lemma B.1 (Hindsight policy gradient, action-value formulation). For an arbitrary goal g , the gradient () of the expected return with respect to  is given by

() =



p( | g , )

g

T -1
p(g)  log p(at | st, g, )
t=1

t p(ak | sk, g, ) k=1 p(ak | sk, g , )

Qt (st, at, g).

(50)

Proof. Starting from Eq. 29, the partial derivative ()/j can be written as

 T -1 () =
j t=1

g

p(g)

s1:t

a1:t

p(s1:t, a1:t

|

 g, )
j

log p(at

|

st, g, )Qt(st, at, g).

(51)

Using importance sampling, for an arbitrary goal g ,

 () =
j

g

T -1

p(g)

p(s1:t, a1:t

t=1 s1:t a1:t

|

g

, ) p(s1:t, a1:t | g, ) p(s1:t, a1:t | g , )

 j

log p(at

|

st, g, )Qt (st, at, g).

(52)

Using Lemma D.1 and rewriting the previous equation using expectations,

 () =
j

g

p(g)E

T -1 t=1

 j

log p(At

|

St, g, )

t p(Ak | Sk, g, ) k=1 p(Ak | Sk, g , )

Qt(St, At, g) | g , 

.

(53)

B.6 THEOREM 4.3

Theorem 4.3 (Hindsight policy gradient, advantage formulation). For an arbitrary (original) goal g , the gradient () of the expected return with respect to  is given by

() =

T -1
p( | g , ) p(g)  log p(at | st, g, )
 g t=1

t p(ak | sk, g, ) k=1 p(ak | sk, g , )

At(st, at, g).

(9)

Proof. The result is obtained by choosing bt = Vt and subtracting Eq. 44 from Eq. 53.

18

Under review as a conference paper at ICLR 2019

B.7 THEOREM B.2

For arbitrary g , j, and , consider the following definitions of f and h.



f ( ) =

g

T -1
p(g)
t=1

 j

log

p(at

|

st, g, )
t

T t -1

=t+1 k=1

p(ak p(ak

| |

sk, g, ) sk, g , )



r(st

, g),

h( ) =

g

T -1
p(g)
t=1

 j

log

p(at

|

t
st, g, )
k=1

p(ak p(ak

| |

sk, g, ) sk, g , )

.

(54) (55)

For every bj  R, using Theorem 4.2 and the fact that E [h(T ) | g , ] = 0 by Lemma 4.1,

 j

()

=

E

[f (T

)

|

g

,

]

=

E

[f (T

)

-

bj h(T

)

|

g

,

]

.

(56)

Theorem B.2. Assuming Var [h(T ) | g , ] > 0, the (optimal constant baseline) bj that minimizes Var [f (T ) - bjh(T ) | g , ] is given by

bj

=

E

[f E

(T )h(T ) | [h(T )2 | g

g , ] , ]

.

(57)

Proof. The result is an application of Lemma D.4.

19

Under review as a conference paper at ICLR 2019

C HINDSIGHT GRADIENT ESTIMATORS

This appendix contains proofs related to the estimators presented in Section 5: Theorem 5.1 (App. C.1) and Theorem 5.2 (App. C.2). Appendix C.3 presents a result that enables a consistency-preserving weighted baseline.

In this appendix, we will consider a dataset D = {( (i), g(i))}iN=1 where each trajectory  (i) is obtained using a policy parameterized by  in an attempt to achieve a goal g(i) chosen by the
environment. Because D is an iid dataset given ,

NN
p(D | ) = p( (1:N), g(1:N) | ) = p( (i), g(i) | ) = p(g(i))p( (i) | g(i), ).

(58)

i=1 i=1

C.1 THEOREM 5.1

Theorem 5.1. The per-decision hindsight policy gradient estimator, given by



1N N
i=1

g

T -1
p(g) 
t=1

log p(At(i)

|

St(i), G(i)

=

g, )
t

T =t+1

t -1

k=1

p(A(ki) | Sk(i), G(i) = p(A(ki) | Sk(i), G(i),

g, ) )



r(St(i),

g),

(11)

is a consistent and unbiased estimator of the gradient () of the expected return.

Proof. Let Ij(N) denote the j-th element of the estimator, which can be written as

Ij(N )

=

1 N

N

I(T (i), G(i), )j ,

i=1

(59)

where



I( , g , )j =

g

p(g)

T -1 t=1

 j

log

p(at

|

st,

g,

)

t

T =t+1

t -1

k=1

p(ak p(ak

| sk, g, )

|

sk ,

g

,

 )

r(st

,

g).

(60)

Using Theorem 4.2, the expected value E Ij(N) |  is given by

E

Ij(N) | 

1N =
N

p(g(i))E

i=1 g(i)

I(T (i), g(i), )j | g(i), 

1N =

p(g(i))  () =

 ().

N i=1 g(i)

j

j

(61)

Therefore, Ij(N) is an unbiased estimator of ()/j.

Conditionally on , the random variable Ij(N) is an average of iid random variables with expected value ()/j (see Eq. 61). By the strong law of large numbers (Sen & Singer, 1994, Theorem 2.3.13),

Ij(N )

-a-.s.

 ().
j

(62)

Therefore, Ij(N) is a consistent estimator of ()/j.

C.2 THEOREM 5.2

Theorem 5.2. The weighted per-decision hindsight policy gradient estimator, given by

N T -1

T

p(g)  log p(At(i) | St(i), G(i) = g, )

i=1 g

t=1

t =t+1

t -1 p(A(ki)|Sk(i),G(i)=g,) k=1 p(Ak(i)|Sk(i),G(i),)

r(St(i), g) ,

N t -1 p(Ak(j)|Sk(j),G(j)=g,)

j=1

k=1 p(Ak(j)|Sk(j),G(j),)

(12)

20

Under review as a conference paper at ICLR 2019

is a consistent estimator of the gradient () of the expected return.

Proof. Let Wj(N) denote the j-th element of the estimator, which can be written as

Wj(N) =

g

T -1
p(g)
t=1

t

T =t+1

X(g, t, t Y (g, t, t

)(jN ) )(jN )

,

where

X(g, t, t

)(jN )

=

1 N

N

X(T (i), G(i), g, t, t , )j ,

i=1

Y

(g, t, t

)j(N )

=

1 N

N

Y (T (i), G(i), g, t, t , )j ,

i=1



X( , g

, g, t, t

, )j

=

t -1

k=1

p(ak p(ak

| sk, g, )

|

sk ,

g

,

 )

 j

log p(at

|

st, g, )r(st

, g),



Y

( , g

, g, t, t

, )j

=

t -1

k=1

p(ak p(ak

| |

sk, g, ) sk, g , )



.

(63)
(64) (65) (66) (67)

Consider the expected value EXi = E X(T (i), G(i), g, t, t , )j |  , which is given by

 



EXi

=

g(i)

t -1
p(g(i))E 
k=1

p(Ak | Sk, g, ) p(Ak | Sk, G = g(i), ) 

 j

log p(At

|

St, g, )r(St

, g)

|

G

=

g(i),  .

(68)

Using the fact that t > t, Lemma D.1, and canceling terms, EXi can be written as

p(g (i) )

g(i)

s1:t

p(st
a1:t -1

|

s1:t

-1, a1:t

-1, G

=

g(i), )p(s1:t

-1, a1:t

-1

|

 g, )
j

log p(at

|

st, g, )r(st

, g).

(69)

Because St  G | S1:t -1, A1:t -1, , 
EXi = E j log p(At | St, g, )r(St , g) | g,  .

(70)

Conditionally on , the variable X(g, t, t )(jN) is an average of iid random variables with expected value EXi . By the strong law of large numbers (Sen & Singer, 1994, Theorem 2.3.13), X(g, t, t )(jN) -a-.s. EXi .

Using Lemma D.1, the expected value EYi = E Y (T (i), G(i), g, t, t , )j |  is given by

EYi = p(g(i))E
g(i)

p(S1(i:t) -1, A(1i:)t -1 | G(i) = g, ) | g(i),  p(S1(i:t) -1, A1(i:)t -1 | g(i), )

= 1.

(71)

Conditionally on , the variable Y (g, t, t )j(N) is an average of iid random variables with expected value 1. By the strong law of large numbers, Y (g, t, t )j(N) -a-.s. 1.

Because both X(g, t, t )j(N) and Y (g, t, t )(jN) converge almost surely to real numbers (Thomas, 2015, Ch. 3, Property 2),

X(g, t, t )j(N) Y (g, t, t )(jN)

-a-.s.

E

 j log p(At | St, g, )r(St , g) | g, 

.

(72)

21

Under review as a conference paper at ICLR 2019

By Theorem 3.1 and the fact that Wj(N) is a linear combination of terms X(g, t, t )j(N)/Y (g, t, t )(jN),

Wj(N) -a-.s.

g

T -1 T
p(g) E
t=1 t =t+1

 j

log

p(At

|

St, g, )r(St

, g)

|

g, 

 = ().
j

(73)

C.3 THEOREM C.1

Theorem C.1. The weighted baseline estimator, given by

N T -1
p(g)  log p(A(ti) | St(i), G(i) = g, )

i=1 g

t=1

converges almost surely to zero.

t p(A(ki)|Sk(i),G(i)=g,) k=1 p(Ak(i)|Sk(i),G(i),)

bt (St(i), g) ,

N t p(Ak(j)|Sk(j),G(j)=g,)

j=1

k=1 p(Ak(j)|Sk(j),G(j),)

(74)

Proof. Let Bj(N) denote the j-th element of the estimator, which can be written as

Bj(N) =

g

p(g) T -1 X(g, t)j(N) , t=1 Y (g, t)j(N)

where

X(g, t)(jN)

=

1 N

N

X(T (i), G(i), g, t, )j ,

i=1

Y

(g, t)j(N)

=

1 N

N

Y (T (i), G(i), g, t, )j ,

i=1

X( , g , g, t, )j =

t p(ak | sk, g, ) k=1 p(ak | sk, g , )

 j

log p(at

|

st, g, )bt(st, g),

Y

( , g

, g, t, )j

=

t k=1

p(ak p(ak

| sk, g, ) . | sk, g , )

(75)
(76) (77) (78) (79)

Using Eqs. 44 and 47, the expected value EXi = E X(T (i), G(i), g, t, )j |  is given by
EXi = p(g(i))E X(T (i), g(i), g, t, )j | g(i),  = 0.
g(i)

(80)

Conditionally on , the variable X(g, t)(jN) is an average of iid random variables with expected value zero. By the strong law of large numbers (Sen & Singer, 1994, Theorem 2.3.13), X(g, t)j(N) -a-.s. 0.

The fact that Y (g, t)j(N) -a-.s. 1 is already established in the proof of Theorem 5.2. Because both
X(g, t)(jN) and Y (g, t)j(N) converge almost surely to real numbers (Thomas, 2015, Ch. 3, Property 2),

X(g, t)(jN) Y (g, t)(jN)

-a-.s.

0.

(81)

Because Bj(N) is a linear combination of terms X(g, t)(jN)/Y (g, t)(jN), Bj(N) -a-.s. 0.

Clearly, if E(N) is a consistent estimator of a some quantity given , then so is E(N) - Bj(N), which allows using this result in combination with Theorem 5.2.
22

Under review as a conference paper at ICLR 2019

D FUNDAMENTAL RESULTS

This appendix presents results required by previous sections: Lemma D.1 (App. D.1), Lemma D.2 (App. D.2), Theorem 4.4 (App. D.4), and Lemma D.4 (App. D.5). Appendix D.3 contains an auxiliary result.

D.1 LEMMA D.1
Lemma D.1. For every  , g, , and 1  t  T - 1,
t-1
p(s1:t, a1:t | g, ) = p(s1)p(at | st, g, ) p(ak | sk, g, )p(sk+1 | sk, ak).
k=1

(82)

Proof. In order to employ backward induction, consider the case t = T - 1. By marginalization,
T -1
p(s1:T -1, a1:T -1 | g, ) = p( | g, ) = p(s1) p(ak | sk, g, )p(sk+1 | sk, ak) (83)
sT sT k=1 T -2
= p(s1)p(aT -1 | sT -1, g, ) p(ak | sk, g, )p(sk+1 | sk, ak), (84)
k=1
which completes the proof of the base case.
Assuming the inductive hypothesis is true for a given 2  t  T - 1 and considering the case t - 1,

t-1

p(s1:t-1, a1:t-1 | g, ) =

p(s1)p(at | st, g, ) p(ak | sk, g, )p(sk+1 | sk, ak)

st at

k=1

t-2

= p(s1)p(at-1 | st-1, g, ) p(ak | sk, g, )p(sk+1 | sk, ak).

k=1

(85) (86)

D.2 LEMMA D.2
Lemma D.2. For every  , g, , and 1  t  T ,
T -1
p(st:T , at:T -1 | s1:t-1, a1:t-1, g, ) = p(st | st-1, at-1) p(ak | sk, g, )p(sk+1 | sk, ak).
k=t
(87)

Proof. The case t = 1 can be inspected easily. Consider 2  t  T . By definition,

p(st:T , at:T -1

|

s1:t-1, a1:t-1, g, )

=

p(s1:T , a1:T -1 | g, ) . p(s1:t-1, a1:t-1 | g, )

(88)

Using Lemma D.1,

p(st:T , at:T -1

|

s1:t-1, a1:t-1, g, )

=

p(s1)

T -1 k=1

p(ak

p(s1)p(at-1 | st-1, g, )

| sk, g, )p(sk+1 | sk, ak)

t-2 k=1

p(ak

|

sk, g, )p(sk+1

|

sk, ak)

(89)

=

T -1 k=t-1

p(ak | sk, p(at-1 |

g, )p(sk+1 st-1, g, )

|

sk ,

ak) .

(90)

23

Under review as a conference paper at ICLR 2019

D.3 LEMMA D.3
Lemma D.3. For every t and , the action-value function Qt is given by Qt(s, a, g) = E r(St+1, g) + Vt+1(St+1, g) | St = s, At = a .

(91)

Proof. From the definition of action-value function and using the fact that St+1  G,  | St, At,

T

Qt (s, a, g) = E [r(St+1, g) | St = s, At = a] + E

r(St , g) | St = s, At = a, g,  .

t =t+2

(92)

Let z denote the second term in the right-hand side of the previous equation, which can also be written as

T

z=

p(st+1, at+1, st+2:T | St = s, At = a, g, )

r(st , g).

st+1 at+1 st+2:T

t =t+2

(93)

Consider the following three independence properties:
St+1  G,  | St, At, At+1  St, At | St+1, G, , St+2:T  St, At | St+1, At+1, G, .

(94) (95) (96)

Together, these properties can be used to demonstrate that

T

z=

p(st+1 | St = s, At = a)

p(at+1 | st+1, g, )

p(st+2:T | st+1, at+1, g, )

r(st , g).

st+1

at+1

st+2:T

t =t+2

(97)

From the definition of value function, z = E Vt+1(St+1, g) | St = s, At = a .

D.4 THEOREM 4.4 Theorem 4.4. For every t and , the advantage function At is given by
At (s, a, g) = E r(St+1, g) + Vt+1(St+1, g) - Vt(s, g) | St = s, At = a .
Proof. The result follows from the definition of advantage function and Lemma D.3.

(10)

D.5 LEMMA D.4

Consider a discrete random variable X and real-valued functions f and h. Suppose also that E [h(X)] = 0 and Var [h(X)] > 0. Clearly, for every b  R, we have E [f (X) - bh(X)] = E [f (X)].
Lemma D.4. The constant b  R that minimizes Var [f (X) - bh(X)] is given by

b

=

E

[f E

(X )h(X [h(X )2 ]

)]

.

(98)

Proof. Let v = Var [f (X) - bh(X)]. Using our assumptions and the definition of variance,

v = E (f (X) - bh(X))2 - E [f (X) - bh(X)]2 = E (f (X) - bh(X))2 - E [f (X)]2 (99)

= E f (X)2 - 2bE [f (X)h(X)] + b2E h(X)2 - E [f (X)]2 .

(100)

24

Under review as a conference paper at ICLR 2019 The first and second derivatives of v with respect to b are given by dv/db = -2E [f (X)h(X)] + 2bE h(X)2 and d2v/db2 = 2E h(X)2 . Our assumptions guarantee that E h(X)2 > 0. Therefore, by Fermat's theorem, if b is a local minimum, then dv/db = 0, leading to the desired equality. By the second derivative test, b must be a local minimum.
25

Under review as a conference paper at ICLR 2019
E EXPERIMENTS
This appendix contains additional information about the experiments introduced in Section 6. Appendix E.1 details policy and baseline representations. Appendix E.2 documents experimental settings. Appendix E.3 presents unabridged results.
E.1 POLICY AND BASELINE REPRESENTATIONS
In every experiment, a policy is represented by a feedforward neural network with a softmax output layer. The input to such a policy is a pair composed of state and goal. A baseline function is represented by a feedforward neural network with a single (linear) output neuron. The input to such a baseline function is a triple composed of state, goal, and time step. The baseline function is trained to approximate the value function using the mean squared (one-step) temporal difference error (Sutton & Barto, 1998). Parameters are updated using Adam (Kingma & Ba, 2014). The networks are given by the following.
Bit flipping environments and grid world environments. Both policy and baseline networks have two hidden layers, each with 256 hyperbolic tangent units. Every weight is initially drawn from a Gaussian distribution with mean 0 and standard deviation 0.01 (and redrawn if far from the mean by two standard deviations), and every bias is initially zero.
Ms. Pac-man environment. The policy network is represented by a convolutional neural network. The network architecture is given by a convolutional layer with 32 filters (8×8, stride 4); convolutional layer with 64 filters (4 × 4, stride 2); convolutional layer with 64 filters (3 × 3, stride 1); and three fully-connected layers, each with 256 units. Every unit uses a hyperbolic tangent activation function. Every weight is initially set using variance scaling (Glorot & Bengio, 2010), and every bias is initially zero. These design decisions are similar to the ones made by Mnih et al. (2015).
A sequence of images obtained from the Arcade Learning Environment (Bellemare et al., 2013) is preprocessed as follows. Individually for each color channel, an elementwise maximum operation is employed between two consecutive images to reduce rendering artifacts. Such 210 × 160 × 3 preprocessed image is converted to grayscale, cropped, and rescaled into an 84 × 84 image xt. A sequence of images xt-12, xt-8, xt-4, xt obtained in this way is stacked into an 84 × 84 × 4 image, which is an input to the policy network (recall that each action is repeated for 13 game ticks). The goal information is concatenated with the flattened output of the last convolutional layer.
FetchPush environment. The policy network has three hidden layers, each with 256 hyperbolic tangent units. Every weight is initially set using variance scaling (Glorot & Bengio, 2010), and every bias is initially zero.
E.2 EXPERIMENTAL SETTINGS
Tables 1 and 2 document the experimental settings. The number of runs, training batches, and batches between evaluations are reported separately for hyperparameter search and definitive runs. The number of training batches is adapted according to how soon each estimator leads to apparent convergence. Note that it is very difficult to establish this setting before hyperparameter search. The number of batches between evaluations is adapted so that there are 100 evaluation steps in total.
Other settings include the sets of policy and baseline learning rates under consideration for hyperparameter search, and the number of active goals subsampled per episode. In Tables 1 and 2, R1 = {×10-k |   {1, 5} and k  {2, 3, 4, 5}} and R2 = { ×10-5 |   {1, 2.5, 5, 7.5, 10}}.
As already mentioned in Section 6, the definitive runs use the best combination of hyperparameters (learning rates) found for each estimator. Every setting was carefully chosen during preliminary experiments to ensure that the best result for each estimator is representative. In particular, the best performing learning rates rarely lie on the extrema of the corresponding search range. In the single case where the best performing learning rate found by hyperparameter search for a goal-conditional policy gradient estimator was such an extreme value (FetchPush, for a small batch size), evaluating one additional learning rate lead to decreased average performance.
26

Under review as a conference paper at ICLR 2019 27

Table 1: Experimental settings for the bit flipping and grid world environments

Runs (definitive) Training batches (definitive) Batches between evaluations (definitive)
Runs (search) Training batches (search) Batches between evaluations (search)
Policy learning rates Baseline learning rates
Episodes per evaluation Maximum active goals per episode

Bit flipping (8 bits)

Batch size 2 Batch size 16

20 5000
50

20 1400
14

10 4000
40

10 1400
14

R1 R1 R1 R1

256 256 

Bit flipping (16 bits)

Batch size 2 Batch size 16

20 15000
150

20 1000
10

10 4000
40

10 1000
10

R1 R1 R1 R1

256 256 

Runs (definitive) Training batches (definitive) Batches between evaluations (definitive)
Runs (search) Training batches (search) Batches between evaluations (search)
Policy learning rates Baseline learning rates
Episodes per evaluation Maximum active goals per episode

Empty room

Batch size 2 Batch size 16

20 2200
22

20 200
2

10 2500
25

10 800 8

R1 R1 R1 R1

256 256 

Four rooms

Batch size 2 Batch size 16

20 10000
100

20 1700
17

10 10000 100

10 3500 35

R1 R1 R1 R1

256 256 

Under review as a conference paper at ICLR 2019 28

Table 2: Experimental settings for the Ms. Pac-man and FetchPush environments

Runs (definitive) Training batches (definitive) Batches between evaluations (definitive)
Runs (search) Training batches (search) Batches between evaluations (search)
Policy learning rates
Episodes per evaluation Maximum active goals per episode

Ms. Pac-man

Batch size 2 Batch size 16

10 40000
400

10 12500
125

5 40000
800

5 12000
120

R2 R2

240 240 3

FetchPush

Batch size 2 Batch size 16

10 40000 400

10 12500 125

5 40000 800

5 15000 300

R2 R2

512 512 3

Under review as a conference paper at ICLR 2019

E.3 RESULTS
This appendix contains unabridged experimental results. Appendices E.3.1 and E.3.2 present hyperparameter sensitivity plots for every combination of environment and batch size. A hyperparameter sensitivity plot displays the average performance achieved by each hyperparameter setting (sorted from best to worst along the horizontal axis). Appendices E.3.3 and E.3.4 present learning curves for every combination of environment and batch size. Appendix E.3.5 presents average performance results. Appendix E.3.6 presents an empirical study of likelihood ratios.
E.3.1 HYPERPARAMETER SENSITIVITY PLOTS (BATCH SIZE 2)

average performance

HPG GCPG 4 HPG+B GCPG+B HPG (ablated LR) HPG+B (ablated LR) 3
2
1
0 hyperparameter setting (best to worst)
Figure 10: Bit flipping (k = 8).

average performance

6 HPG GCPG HPG+B
5 GCPG+B HPG (ablated LR) HPG+B (ablated LR)
4
3
2
1
0 hyperparameter setting (best to worst)
Figure 11: Bit flipping (k = 16).

average performance

20.0

HPG

9

GCPG

17.5

HPG+B

8

GCPG+B

15.0

HPG (ablated LR) HPG+B (ablated LR)

7

12.5 6

average performance

10.0 5

7.5 4

5.0 3

2.5 2

0.0 hyperparameter setting (best to worst)

1

Figure 12: Empty room.

HPG GCPG HPG+B GCPG+B HPG (ablated LR) HPG+B (ablated LR)
hyperparameter setting (best to worst)
Figure 13: Four rooms.

average performance

7 HPG

GCPG

7.0

6 6.5

average performance

5 6.0
5.5 4
5.0 3
4.5 2
4.0
1 3.5

hyperparameter setting (best to worst)

Figure 14: Ms. Pac-man.

HPG GCPG
hyperparameter setting (best to worst)
Figure 15: FetchPush.

29

Under review as a conference paper at ICLR 2019

E.3.2 HYPERPARAMETER SENSITIVITY PLOTS (BATCH SIZE 16)

average performance

HPG GCPG 4 HPG+B GCPG+B
3
2
1
0 hyperparameter setting (best to worst)
Figure 16: Bit flipping (k = 8).

average performance

HPG 7 GCPG
HPG+B 6 GCPG+B
5
4
3
2
1
0 hyperparameter setting (best to worst)
Figure 17: Bit flipping (k = 16).

average performance

20.0 17.5 15.0

HPG GCPG HPG+B GCPG+B

9 8 7

average performance

12.5 6

10.0 5

7.5 4

5.0 2.5 0.0
hyperparameter setting (best to worst)

3 2 1

Figure 18: Empty room.

HPG

14

6.5 GCPG

6.0 12

average performance

5.5 10
5.0 8
4.5
6 4.0

3.5 4

hyperparameter setting (best to worst)

Figure 20: Ms. Pac-man.

HPG GCPG HPG+B GCPG+B
hyperparameter setting (best to worst)
Figure 19: Four rooms.
HPG GCPG
hyperparameter setting (best to worst)
Figure 21: FetchPush.

average performance

30

Under review as a conference paper at ICLR 2019

E.3.3 LEARNING CURVES (BATCH SIZE 2)

average return

5
4
3
2
1 HPG GCPG HPG+B
0 GCPG+B 20 40 60 80 100 evaluation step
Figure 22: Bit flipping (k = 8).

average return

8
6
4
2 HPG GCPG HPG+B GCPG+B
0 20 40 60 80 100 evaluation step
Figure 23: Bit flipping (k = 16).

average return

10

20 8

average return

15 6

10 4

5 HPG

HPG

GCPG

2

GCPG

HPG+B

HPG+B

0 GCPG+B

GCPG+B

20 40 60 80 100 evaluation step

20 40 60 80 100 evaluation step

Figure 24: Empty room.

Figure 25: Four rooms.

average return

10 12
8 10
6 8
46
24 HPG GCPG
20 40 60 80 100 evaluation step
Figure 26: Ms. Pac-man.

average return

HPG GCPG 20 40 60 80 100 evaluation step
Figure 27: FetchPush.

31

Under review as a conference paper at ICLR 2019

E.3.4 LEARNING CURVES (BATCH SIZE 16)

average return

5
4
3
2
1 HPG GCPG HPG+B
0 GCPG+B 20 40 60 80 100 evaluation step
Figure 28: Bit flipping (k = 8).

average return

8
6
4
2 HPG GCPG HPG+B GCPG+B
0 20 40 60 80 100 evaluation step
Figure 29: Bit flipping (k = 16).

average return

10 20

8 15

average return

6 10

4

5 HPG

HPG

GCPG HPG+B

2

GCPG HPG+B

GCPG+B 0

GCPG+B

20 40 60 80 100 evaluation step

20 40 60 80 100 evaluation step

Figure 30: Empty room.

Figure 31: Four rooms.

average return

18
10 16

8 14

average return

12 6
10

48

6

2

HPG

4

GCPG

02 20 40 60 80 100

evaluation step

Figure 32: Ms. Pac-man.

HPG GCPG 20 40 60 80 100 evaluation step
Figure 33: FetchPush.

E.3.5 AVERAGE PERFORMANCE RESULTS Table 3 presents average performance results for every combination of environment and batch size.

32

Under review as a conference paper at ICLR 2019

Table 3: Definitive average performance results

HPG GCPG HPG+B GCPG+B

Bit flipping (8 bits)

Batch size 2 Batch size 16

4.60 ± 0.06 1.81 ± 0.61 3.40 ± 0.46 0.64 ± 0.58

4.72 ± 0.02 3.44 ± 0.30 4.04 ± 0.10 3.31 ± 0.58

Bit flipping (16 bits)

Batch size 2 Batch size 16

7.11 ± 0.12 0.00 ± 0.00 5.35 ± 0.40 0.00 ± 0.00

7.39 ± 0.24 0.00 ± 0.00 6.09 ± 0.29 0.00 ± 0.00

HPG GCPG HPG+B GCPG+B

Empty room

Batch size 2 Batch size 16

20.22 ± 0.37 12.54 ± 1.01 19.90 ± 0.29 12.69 ± 1.16

16.83 ± 0.84 10.96 ± 1.24 17.12 ± 0.44 10.68 ± 1.36

Four rooms

Batch size 2 Batch size 16

7.38 ± 0.16 4.64 ± 0.57 7.28 ± 1.28 4.26 ± 0.55

8.75 ± 0.12 6.12 ± 0.54 8.08 ± 0.18 6.61 ± 0.49

HPG GCPG

Ms. Pac-man
Batch size 2 Batch size 16
6.58 ± 1.96 6.80 ± 0.64 5.29 ± 1.67 6.92 ± 0.58

FetchPush
Batch size 2 Batch size 16
6.10 ± 0.34 13.15 ± 0.40 3.48 ± 0.15 4.42 ± 0.28

33

Under review as a conference paper at ICLR 2019

E.3.6 LIKELIHOOD RATIO PLOTS
This appendix presents a study of the active (normalized) likelihood ratios computed by agents during training. A likelihood ratio is considered active if and only if it multiplies a non-zero reward (see Expression 12). Note that only these likelihood ratios affect gradient estimates based on HPG. This study is conveyed through plots that encode the distribution of active likelihood ratios computed during training, individually for each time step within an episode. Each plot corresponds to an agent that employs HPG and obtains the highest definitive average performance for a given environment (Figs. 34-39). Note that the length of the largest bar for a given time step is fixed to aid visualization. The most important insight provided by these plots is that likelihood ratios behave very differently across environments, even for equivalent time steps (for instance, compare bit flipping environments to grid world environments). In contrast, after the first time step, the behavior of likelihood ratios changes slowly across time steps within the same environment. In any case, alternative goals have a significant effect on gradient estimates, which agrees with the results presented in Section 6.
1.0
0.8
0.6
0.4
0.2
0.0 12345678
time step
Figure 34: Bit flipping (k = 8, batch size 16).

(normalized) likelihood ratio histogram

(normalized) likelihood ratio histogram

1.0 0.8 0.6 0.4 0.2 0.0
1

3 5 7 9 11
time step
Figure 35: Bit flipping (k = 16, batch size 16).

13

16

(normalized) likelihood ratio histogram

1.0 0.8 0.6 0.4 0.2 0.0
1

5 9 13 18 22 26 31
time step
Figure 36: Empty room (batch size 16).

34

Under review as a conference paper at ICLR 2019

(normalized) likelihood ratio histogram

1.0 0.8 0.6 0.4 0.2 0.0
1

5 9 13 18 22 26 31
time step
Figure 37: Four rooms (batch size 16).

(normalized) likelihood ratio histogram

1.0 0.8 0.6 0.4 0.2 0.0
1

4 8 12 15 19 23 27
time step
Figure 38: Ms. Pac-man (batch size 16).

(normalized) likelihood ratio histogram

1.0 0.8 0.6 0.4 0.2 0.0
1

7 14 21 28 35 42 49
time step
Figure 39: FetchPush (batch size 16).

35

