Under review as a conference paper at ICLR 2019
A CLOSER LOOK AT FEW-SHOT CLASSIFICATION
Anonymous authors Paper under double-blind review
ABSTRACT
Few-shot classification aims to learn a classifier to recognize unseen classes during training with limited labeled examples. While significant progress has been made, the growing complexity of network designs, meta-learning algorithms, and differences in implementation details make a fair comparison difficult. In this paper, we present 1) a consistent comparative analysis of several representative few-shot classification algorithms, with results showing that deeper backbones significantly reduce the gap across methods including the baseline, 2) a slightly modified baseline method that surprisingly achieves competitive performance when compared with the state-of-the-art on both the mini-ImageNet and the CUB datasets, and 3) a new experimental setting for evaluating the cross-domain generalization ability for few-shot classification algorithms. Our results reveal that reducing intra-class variation is an important factor when the feature backbone is shallow, but not as critical when using deeper backbones. In a realistic, cross-domain evaluation setting, we show that a baseline method with a standard fine-tuning practice compares favorably against other state-of-the-art few-shot learning algorithms.
1 INTRODUCTION
Deep learning models have achieved state-of-the-art performance on visual recognition tasks such as image classification. The strong performance, however, heavily relies on training a network with abundant labeled instances with diverse visual variations (e.g., thousands of examples for each new class even with pre-training on large-scale dataset with base classes). The human annotation cost as well as the scarcity of data in some classes (e.g., rare species) significantly limit the applicability of current vision systems to learn new visual concepts efficiently. In contrast, the human visual systems can recognize new classes with extremely few labeled examples. It is thus of great interest to learn to generalize to new classes with a limited amount of labeled examples for each novel class.
The problem of learning to generalize to unseen classes during training, known as few-shot classification, has attracted considerable attention Vinyals et al. (2016); Snell et al. (2017); Finn et al. (2017); Ravi & Larochelle (2017); Sung et al. (2018); Garcia & Bruna (2018); Qi et al. (2018). One promising direction to few-shot classification is the meta-learning paradigm where transferable knowledge is extracted and propagated from a collection of tasks to prevent overfitting and improve generalization. Examples include model initialization based methods Ravi & Larochelle (2017); Finn et al. (2017), metric learning methods Vinyals et al. (2016); Snell et al. (2017); Sung et al. (2018), and hallucination based methods Antoniou et al. (2018); Hariharan & Girshick (2017); Wang et al. (2018). Another line of work Gidaris & Komodakis (2018); Qi et al. (2018) also demonstrates promising results by directly predicting the weights of the classifiers for novel classes.
Limitations. While many few-shot classification algorithms have reported improved performance over the state-of-the-art, there are two main challenges that prevent us from making a fair comparison and measuring the actual progress. First, the discrepancy of the implementation details among multiple few-shot learning algorithms obscures the relative performance gain. The performance of baseline approaches can also be significantly under-estimated (e.g., training without data augmentation). Second, while the current evaluation focuses on recognizing novel class with limited training examples, these novel classes are sampled from the same dataset. The lack of domain shift between base and novel classes makes the evaluation scenarios unrealistic.
Our work. In this paper, we present a detailed empirical study to shed new light on the few-shot classification problem. First, we conduct consistent comparative experiments to compare several
1

Under review as a conference paper at ICLR 2019
representative few-shot classification methods on common ground. Our results show that using a deep backbone shrinks the performance gap between different methods. Second, by replacing the linear classifier with a distance-based classifier as used in Gidaris & Komodakis (2018); Qi et al. (2018), the baseline method is surprisingly competitive to current state-of-art meta-learning algorithms. Third, we introduce a realistic evaluation setting where there exists domain shift between base and novel classes (e.g., sampling base classes from generic object categories and novel classes from fine-grained categories). Our results show that sophisticated few-shot learning algorithms do not provide performance improvement over the baseline under this setting. Through making the source code and model implementations with a consistent evaluation setting publicly available, we hope to foster future progress in the field.
Our contributions.
1. We provide a unified testbed for several different few-shot classification algorithms for a fair comparison. Our empirical evaluation results reveal that the use of a shallow backbone commonly used in existing work leads to favorable results for methods that explicitly reduce intra-class variation. Increasing the model capacity of the feature backbone reduces the performance gap between different methods.
2. We show that a baseline method with a distance-based classifier can be surprisingly competitive with the state-of-the-art meta-learning methods on both mini-ImageNet and CUB datasets.
3. We investigate a realistic evaluation setting where base and novel classes are sampled from different domains. We show that current few-shot classification algorithms fail to address such domain shifts and are inferior to the baseline method, highlighting the importance of learning to adapt to domain differences in few-shot learning.
2 RELATED WORK
Given abundant training examples for the base classes, few-shot learning algorithms aim to learn to recognizing novel classes with a limited amount of labeled examples. Much efforts have been devoted to overcome the data efficiency issue. In the following, we discuss representative few-shot learning algorithms organized into three main categories: initialization based, metric learning based, and hallucination based methods.
Initialization based methods tackle the few-shot learning problem by "learning to fine-tune". One approach aims to learn good model initialization (i.e., the parameters of a network) so that the classifiers for novel classes can be learned with a limited number of labeled examples and small number of gradient steps Finn et al. (2017). Another line of work focuses on learning an optimizer. Examples include the LSTM-based meta-learner for replacing the stochastic gradient decent optimizer Ravi & Larochelle (2017) and the weight-update mechanism with an external memory Munkhdalai & Yu (2017). While these initialization based methods are capable of achieving rapid adaption with a limited number of training examples for novel classes, our experiments show that these methods have difficulty in handling domain shifts between base and novel classes.
Hallucination based methods directly deal with data deficiency by "learning to augment". This class of methods learns a generator from data in the base classes and use the learned generator to hallucinate new novel class data for data augmentation. One type of generator aims at transferring appearance variations exhibited in the base classes. These generators either transfer variance in base class data to novel classes Hariharan & Girshick (2017), or use GAN models Antoniou et al. (2018) to transfer the style. Another type of generators does not explicitly specify what to transfer, but directly integrate the generator into a meta-learning algorithm for improving the classification accuracy Wang et al. (2018). Since hallucination based methods often work with other few-shot methods together (e.g. use hallucination based and metric learning based methods together) and lead to complicated comparison, we do not include these methods in our comparative study and leave it for future work.
Distance metric learning based methods address the few-shot classification problem by "learning to compare". The intuition is that if a model can determine the similarity of two images, it can classify an unseen input image with the labeled instances Koch et al. (2015). To learn a sophisticated comparison models, meta-learning based methods make their prediction conditioned on distance or
2

Under review as a conference paper at ICLR 2019

Training stage

Base class data (Many)

Feature extractor

Classifier

Fine-tuning stage

Novel class data (Few)

Fixed

Feature extractor

Classifier

Softmax 
Softmax 

Baseline
Linear layer

Classifier

Baseline++
Cosine distance
...

...

Figure 1: Baseline and Baseline++ few-shot classification methods. Both the baseline and baseline++ method train a feature extractor f and classifier C(.|Wb) with base class data in the training stage In the fine-tuning stage, we fix the network parameters  in the feature extractor f and train a new classifier C(.|Wn) with the given labeled examples in novel classes. The baseline++ method differs from the baseline model in the use of cosine distances between the input
feature and the weight vector for each class that aims to reduce intra-class variations.

metric to few labeled instances during the training process. Examples of distance metrics include cosine similarity Vinyals et al. (2016), Euclidean distance to class-mean representation Snell et al. (2017), CNN-based relation module Sung et al. (2018), and graph neural network Garcia & Bruna (2018). In this paper, we compare the performance of three distance metric learning methods. Our results show that a simple baseline method with a distance-based classifier (without training over a collection of tasks/episodes as in meta-learning) achieves competitive performance with respect to other sophisticated algorithms.
Besides meta-learning methods, both Gidaris & Komodakis (2018) and Qi et al. (2018) develop a similar method to our Baseline++ (described later in Section 3.2). The method in Gidaris & Komodakis (2018) learns a weight generator to predict the novel class classifier using an attentionbased mechanism (cosine similarity), and the Qi et al. (2018) directly use novel class features as their weights. Our Baseline++ can be viewed as a simplified architecture of these methods because our focus is to show that simply reducing intra-class variation in a baseline method using the base class data leads to competitive performance.
Domain adaptation techniques aim to reduce the domain shifts between source and target domain Pan et al. (2010); Ganin & Lempitsky (2015), as well as novel tasks in a different domain Tzeng et al. (2015); Hsu et al. (2018). Similar to domain adaptation, we also investigate the impact of domain difference on few-shot classification algorithms in Section 4.5. In contrast to most domain adaptation problems where a large amount of data is available in the target domain (either labeled or unlabeled), our problem setting differs because we only have very few examples in the new domain. Very recently, Motiian et al. (2017) addresses the few-shot domain adaptation problem. Our work instead focuses on the few-shot classification performance under domain differences.
3 OVERVIEW OF FEW-SHOT CLASSIFICATION ALGORITHMS
In this section, we first outline the details of the baseline model (Section 3.1) and its variant (Section 3.2), followed by describing representative meta-learning algorithms (Section 3.3) studied in our experiments. Given abundant base class labeled data Xb and a small amount of novel class labeled data Xn, the goal of few-shot classification algorithms is to train classifiers for novel classes (unseen during training) with few labeled examples.
3

Under review as a conference paper at ICLR 2019

3.1 BASELINE

Our baseline model follows the standard transfer learning procedure of network pre-training and fine-tuning. Figure 1 illustrates the overall procedure.

Training stage. We the classifier C(·|Wb)

train the feature extractor f (parametrized by the weight

(parametrized by the network parameters  ) and matrix Wb  Rd×c) from scratch by minimizing

a standard cross-entropy classification loss Lpred using the training examples in the base classes

xi  Xb. Here, we denote the dimension of the encoded feature as d and the number of output

classes as c. The classifier C(.|Wb) consists of a linear layer Wb f (xi) followed by a softmax

function  .

Fine-tuning stage. To adapt the model to recognize novel classes in the fine-tuning stage, we fix
the pre-trained network parameter  in our feature extractor f and train a new classifier C(.|Wn) (parametrized by the weight matrix Wn) by minimizing Lpred using few labeled of examples (i.e., the support set) in the novel classes Xn.

3.2 BASELINE++

In addition to the baseline model, we also implement a variant of the baseline model, denoted as Baseline++, which explicitly reduces intra-class variation among features during training. The importance of reducing intra-class variations of features has been highlighted in deep metric learning Hu et al. (2015) and few-shot classification methods Gidaris & Komodakis (2018).
The training procedure of Baseline++ is the same as the original Baseline model except for the classifier design. As shown in Figure 1, we still have a weight matrix Wb  Rd×c of the classifier in the training stage and a Wn in the fine-tuning stage in Baseline++. The classifier design, however, is different from the linear classifier used in the Baseline. Take the weight matrix Wb as an example. We can write the weight matrix Wb as [w1, w2, ...wc], where each class has a d-dimensional weight vector. In the training stage, for an input feature f (xi) where xi  Xb, we compute its cosine similarity to each weight vector [w1, · · · , wc] and get the similarity scores [cos( f (xi), w1), · · · , cos( f (xi), wc)] for all classes. We can then obtain the prediction probability for each class by normalizing these similarity scores with a softmax function. Here, the classifier makes a prediction based on the cosine distance between the input feature and the learned weight vectors representing each class. Consequently, training the model with this distance-based classifier explicitly reduce intra-class variations. Intuitively, the learned weight vectors [w1, · · · , wc] can be interpreted as prototypes (similar to Snell et al. (2017); Vinyals et al. (2016)) for each class and the classification is based on the distance of the input feature to these learned prototypes. The softmax function prevents the learned weight vectors collapsing to zeros.
We clarify that the network design in Baseline++ is not our contribution. The concept of distancebased classification has been extensively studied in Mensink et al. (2012) and recently has been revisited in the few-shot classification setting Gidaris & Komodakis (2018); Qi et al. (2018).

3.3 META-LEARNING ALGORITHMS

Here we describe the formulations of meta-learning methods used in our study. We consider three distance metric learning based methods (MatchingNet Vinyals et al. (2016), ProtoNet Snell et al. (2017), and RelationNet Sung et al. (2018)) and one initialization based method (MAML Finn et al. (2017)). While meta-learning is not a clearly defined, Vinyals et al. (2016) considers a few-shot classification method as meta-learning if the prediction is conditioned on a small support set S, because it makes the training procedure explicitly learn to learn from a given small support set.
As shown in Figure 2, meta-learning algorithms consist of a meta-training and a meta-testing stage. In the meta-training stage, it would first randomly select N classes, and sample small base support set Sb and a base query set Qb from data samples within these classes. The objective is to train a classification model M that minimizes N-way prediction loss LN-way of the samples in the query set Qb. The classifier M is conditioned on support set Sb. That is, given a different support set, the prediction would be different (similar to the nearest neighbor classifier). By making prediction conditioned on the given support set, a meta-learning method can learn how to learn from limited data through training from a collection of tasks (episodes). In the meta-testing stage, all novel class

4

Under review as a conference paper at ICLR 2019

Meta-training stage
Sampled  classes

Meta-testing stage

Base class data (Many)
MatchingNet
Feature extractor Cosine
distance

Base support set

Base query set

"
Support set conditioned model

Novel support set
(Novel class data )

Support set conditioned model

ProtoNet Class
mean

RelationNet Class
mean

MAML

Euclidean distance

Relation Module

Gradient

Linear Linear

Figure 2: Meta-learning few-shot classification algorithms. The meta-learning classifier M(·|S)
is conditioned on the support set S. (Top) In the meta-train stage, the support set Sb and the query set Qb are first sampled from random N classes, and then train the parameters in M(.|Sb) to
minimize the N-way prediction loss LN-way. In the meta-testing stage, the adapted classifier M(.|Sn) can predict novel classes with the support set in the novel classes Sn. (Bottom) The design of M(·|S) in different meta-learning algorithms.

data Xn are considered as the support set for novel classes Sn, and the classification model M can be adapted to predict novel classes with the new support set Sn.
Different meta-learning methods differ in their strategies to make prediction conditioned on support set (see Figure 2). For both MatchingNet Vinyals et al. (2016) and ProtoNet Snell et al. (2017), the prediction of the examples in a query set Q is based on comparing the distance between the query feature and the support feature from each class. MatchingNet compares cosine distance between the query feature and each support feature, and computes average cosine distance for each class, while ProtoNet compares the Euclidean distance between query features and the class mean of support features. RelationNet Sung et al. (2018) shares a similar idea, but it replaces distance with a learnable relation module. The MAML method Finn et al. (2017) is an initialization based meta-learning algorithm, where the support set is used to update the model parameters using few gradient updates.

4 EXPERIMENTAL RESULTS
4.1 EXPERIMENTAL SETUP
Datasets and scenarios. We address the few-shot classification problem under three scenarios: 1) generic object recognition, 2) fine-grained image classification, and 3) cross-domain adaptation.
For object recognition, we use the mini-ImageNet dataset commonly used in evaluating few-shot classification algorithms. The mini-ImageNet dataset consists of a subset of 100 classes from the ImageNet dataset Deng et al. (2009) and contains 600 images for each class. It was first proposed by Vinyals et al. (2016), but recent works use the follow-up setting provided by Ravi & Larochelle (2017), which is composed of randomly selected 64 base, 16 validation, and 20 novel classes.
For fine-grained classification, we use CUB-200-2011 Wah et al. (2011) (referred to as the CUB hereafter) dataset. The CUB dataset contains 200 classes and 11,788 images in total. Following the evaluation protocol of Hilliard et al. (2018), we randomly split the dataset into 100 base, 50 validation, and 50 novel classes.
For the cross-domain scenario (mini-ImageNet CUB), we use mini-ImageNet as our base class and the 50 validation and 50 novel class from CUB. Evaluating the cross-domain scenario allows us to understand the effects of domain shifts to existing few-shot classification approaches.
5

Under review as a conference paper at ICLR 2019

Table 1: Validating our re-implementation. We validate our few-shot classification implementation on the mini-ImageNet dataset using a Conv-4 backbone. We report the mean of 600 randomly generated test episodes as well as the 95% confidence intervals. Our reproduced results to all few-shot methods do not fall behind by more than 2% to the reported results in the literature. We attribute the slight discrepancy to different random seeds and minor implementation differences in each method. "Baseline" denotes the results without applying data augmentation during training. ProtoNet# indicates performing 30-way classification in 1-shot and 20-way in 5-shot during the meta-training stage. Citations here refer to the source of the reported results.

Method
Baseline Baseline Ravi & Larochelle (2017)
MatchingNet Ravi & Larochelle (2017) ProtoNet ProtoNet# Snell et al. (2017) MAML Finn et al. (2017) RelationNet Sung et al. (2018)

1-shot

Reported

Ours

- 42.11 ± 0.71 41.08 ± 0.70 36.35 ± 0.64

43.56 ± 0.84 -
49.42 ± 0.78 48.07 ± 1.75 50.44 ± 0.82

48.14 ± 0.78 44.42 ± 0.84 47.74 ± 0.84 46.47 ± 0.82 49.31 ± 0.85

5-shot

Reported

Ours

- 62.53 ±0.69 51.04 ± 0.65 54.50 ±0.66

55.31 ±0.73 -
68.20 ±0.66 63.15 ±0.91 65.32 ±0.70

63.48 ±0.66 64.24 ±0.72 66.68 ±0.68 62.71 ±0.71 66.60 ±0.69

Implementation details. In the training stage for the Baseline and the Baseline++ methods, we train 400 epochs with a batch size of 16. In the meta-training stage for meta-learning methods, we train 60,000 iterations for 1-shot and 40,000 iterations for 5-shot tasks. In each iteration, we sample N classes to form N-way classification (N is 5 in both meta-training and meta-testing stages unless otherwise mentioned). For each class, we pick k labeled instances as our support set and 16 instances for the query set for a k-shot task.
In the fine-tuning or meta-testing stage for all methods, we average the results over 600 experiments. In each experiment, we randomly sample 5 classes from novel classes, and in each class, we also pick k instances for the support set and 16 for the query set. For Baseline and Baseline++, we use the entire support set to train a new classifier for 100 iterations with a batch size of 4. For meta-learning methods, we obtain the classification model conditioned on the support set as in Section 3.3.
All methods are trained from scratch and use the Adam optimizer with initial learning rate 10-3. We apply standard data augmentation including random crop, left-right flip, and color jitter in both the training or meta-training stage. Also, following Snell et al. (2017), we use the validation set to select the best-learned model for meta-learning methods during the meta-training stage.
Some implementation details have been adjusted individually for each method. For MatchingNet, we use an FCE classification layer without fine-tuning in all experiments and also multiply cosine similarity by a constant scalar. For RelationNet, we replace the L2 norm with a softmax layer to expedite training. For MAML, we use a first-order approximation in the gradient for efficiency. The approximation has been shown in the original paper to have almost the same performance as the full version. We choose the first-order approximation for its efficiency.
4.2 STANDARD SETTING REPRODUCTION
We now conduct experiments on the most common setting in few-shot classification, 1-shot and 5-shot classification, i.e., 1 or 5 labeled instances are available from each novel class. We use a four-layer convolution backbone (Conv-4) as in Snell et al. (2017) and perform 5-way classification for only novel classes during the fine-tuning or meta-testing stage.
To validate the correctness of our implementation, we first compare our results to reported numbers for the mini-ImageNet dataset in Table 1. Note that we have a ProtoNet#, as we use 5-way classification in the meta-training and meta-testing stages for all meta-learning methods as mentioned in Section 4.1; however, the official reported results from ProtoNet uses 30-way for one shot and 20-way for five shot in the meta-training stage in spite of using 5-way in the meta-testing stage. We report this result for completeness.
6

Under review as a conference paper at ICLR 2019

Table 2: Few-shot classification results for both the mini-ImageNet and CUB datasets. The Baseline++ consistently improves the Baseline model by a large margin and is competitive with the state-of-the-art meta-learning methods. All experiments are from 5-way classification with a Conv-4 backbone and data augmentation.

Method
Baseline Baseline++
MatchingNet Vinyals et al. (2016) ProtoNet Snell et al. (2017) MAML Finn et al. (2017) RelationNet Sung et al. (2018)

CUB

1-shot

5-shot

47.12 ± 0.74 64.16 ± 0.71 60.53 ± 0.83 79.34 ± 0.61

61.16 ± 0.89 51.31 ± 0.91 55.92 ± 0.95 62.45 ± 0.98

72.86 ± 0.70 70.77 ± 0.69 72.09 ± 0.76 76.11 ± 0.69

mini-ImageNet

1-shot

5-shot

42.11 ± 0.71 62.53 ±0.69 48.24 ± 0.75 66.43 ±0.63

48.14 ± 0.78 44.42 ± 0.84 46.47 ± 0.82 49.31 ± 0.85

63.48 ±0.66 64.24 ±0.72 62.71 ±0.71 66.60 ±0.69

Baseline

Baseline++

MatchingNet

ProtoNet

MAML

RelationNet

CUB

mini-ImageNet

1-shot

5-shot

1-shot

5-shot

75% 90%

55%

80%

65% 80% 55% 70% 45% 60%

50% 45% 40%

75% 70% 65% 60%

ResNet-34 ResNet-18 ResNet-10 Conv-6 Conv-4
ResNet-34 ResNet-18 ResNet-10 Conv-6 Conv-4
ResNet-34 ResNet-18 ResNet-10 Conv-6 Conv-4
ResNet-34 ResNet-18 ResNet-10 Conv-6 Conv-4

Figure 3: Few-shot classification accuracy vs. backbone depth. In the CUB dataset, gaps among different methods diminish as the backbone gets deeper. In mini-ImageNet 5-shot, some meta-learning methods are even beaten by Baseline with a deeper backbone. (Please refer to Figure A2 and Table A2 for larger figure and detailed statistics.)

From Table 1, we can observe that all of our re-implementation for meta-learning methods do not fall more than 2% behind reported performance. These minor differences can be attributed to our modifications of some implementation details to ensure a fair comparison among all methods, such as using the same optimizer for all methods.
Moreover, our implementation of existing work also improves the performance of some of the methods. For example, our results show that the 5-shot Baseline can be improved by a large margin since previous implementations of the Baseline do not include data augmentation in their training stage, which leads to over-fitting. While our Baseline is not as good as reported in 1-shot, our Baseline with augmentation still improves on it, and could be even higher if our reproduced Baseline matches the reported statistics. In either case, the performance of the Baseline method is severely underestimated. We also improve the results of MatchingNet by adjusting the input score to the softmax layer to a more appropriate range as stated in Section 4.1. On the other hand, while ProtoNet# is not as good as ProtoNet, as mentioned in the original paper a more challenging setting in the metatraining stage leads to better accuracy. We choose to use a consistent 5-way classification setting in subsequent experiments to have a fair comparison to other methods. This issue can be resolved by using a deeper backbone as shown in Section 4.3.
After validating our reimplementation, we now report the accuracy in Table 2. Besides additionally reporting results on the CUB dataset, we also compare Baseline++ to other methods. Here, we find that Baseline++ improves the Baseline by a large margin and becomes competitive even when compared with other meta-learning methods. The results demonstrate that reducing intra-class variation is an important factor in the current few-shot classification problem setting.
However, note that our current setting only uses a 4-layer backbone, while a deeper backbone could inherently reduce intra-class variation. Thus, we conduct experiments to investigate the effects of backbone depth in the next section.
7

Under review as a conference paper at ICLR 2019
4.3 EFFECT OF INCREASING THE NETWORK DEPTH
Now we change the backbone depth to reduce intra-class variation for all methods. See appendix for statistics on how network depth correlates with intra-class variation. Starting from Conv-4, we gradually increase the feature backbone to Conv-6, ResNet-10, 18 and 34, where Conv-6 have two additional convolution blocks without pooling after Conv-4. ResNet-18 and 34 are the same as described in He et al. (2016), while ResNet-10 is a simplified version of ResNet-18 where only one residual building block is used in each layer. The statistics of this experiment would also be helpful to other works to make a fair comparison under different backbones.
Results of the CUB dataset shows a clearer tendency in Figure 3. As the backbone gets deeper, the gap among different methods reduces drastically. Another observation is how ProtoNet improves rapidly as the backbone gets deeper. While using a consistent 5-way classification as discussed in Section 4.2 degrades the accuracy of ProtoNet with Conv-4, it works well with a deeper backbone. Thus, the two observations above demonstrate that in the CUB dataset, the gap among existing methods would be reduced if their intra-class variation are all reduced by a deeper backbone.
However, the result of mini-ImageNet in Figure 3 is much more complicated. In the 5-shot setting, both Baseline and Baseline++ achieve good performance with a deeper backbone, but some metalearning methods become worse relative to them. Thus, other than intra-class variation, we can assume that the dataset is also important in few-shot classification. One difference between CUB and mini-ImageNet is their domain difference in base and novel classes since classes in mini-ImageNet have a larger divergence than CUB in a word-net hierarchy Miller (1995). Thus, in the next section, we discuss how domain differences between base and novel classes impact few-shot results.
4.4 EFFECT OF DOMAIN DIFFERENCES BETWEEN BASE AND NOVEL CLASSES
To further dig into the issue of domain difference, we require scenarios that provide such variations. Thus, besides the fine-grained classification and object recognition scenarios, we propose a new cross-domain scenario: mini-ImageNet CUB as mentioned in Section 4.1. We argue that this is quite a realistic scenario, since collecting images from a general class may be easy (e.g. due to increased availability) but collecting images from fine-grained classes might be more difficult.
Here we only discuss results with ResNet-18 since the importance of deeper backbone has been discussed before. As shown in Table 3, the Baseline becomes better than meta-learning methods under this scenario. While meta-learning methods learn to learn from the support set during the meta-training stage, they could not learn to adapt to novel classes that are too different since all of the base support sets are within the same dataset. A similar concept is also mentioned in Vinyals et al. (2016). In contrast, the Baseline simply replaces and trains a new classifier based on the few given novel class data, which allows it to quickly adapt to a novel class and is less affected by domain difference. The Baseline also beats Baseline++, possibly because additionally reducing intra-class variation compromises adaptability. In Figure 4, we can further observe how Baseline accuracy becomes relatively higher as the domain difference gets larger. That is, as the domain difference grows larger, the adaptation based on a few novel class instances becomes more important.
However, this is not to say that only Baseline can properly adapt. In the next section, we discuss how to adapt further meta-learning methods based on given few examples.
4.5 EFFECT OF FURTHER ADAPTATION
To further adapt meta-learning methods as in Baseline, an intuitive way is to fix the features and train a new classifier. We apply this adaptation to ProtoNet and MatchingNet, while RelationNet is not applicable to this adaptation as its features are convolution maps rather than vectors. For MAML, it is not feasible to fix the feature as it is merely an initialization. In contrast, since it updates the model with the support set for only a few iterations, we can adapt further by updating for as many iterations as is required to train a new classification layer, which is 100 updates as mentioned in Section 4.1.
The results of further adaptation are shown in Table 4; we can observe that the performance of MatchingNet and MAML improves significantly after further adaptation, particularly in the miniImageNet CUB scenario. The results demonstrate that lack of adaptation is the reason they fall behind the Baseline. However, changing the setting in the meta-testing stage could lead to incon-
8

Under review as a conference paper at ICLR 2019

Baseline Baseline++
MatchingNet ProtoNet MAML RelationNet

mini-ImageNet CUB
65.57±0.70 62.04±0.76
53.07±0.74 62.02±0.70 51.34±0.72 57.71±0.73

Table 3: 5-shot accuracy under the cross-domain scenario with a ResNet-18 backbone. Baseline outperforms all other methods under this scenario.

Baseline Baseline++ MatchingNet ProtoNet MAML RelationNet

90% 80% 70% 60% 50% 40%
CUB Small

miniImageNet miniImageNet -> CUB

Domain Difference

Large

Figure 4: 5-shot accuracy in different scenarios with a ResNet-18 backbone. The Baseline model performs relative well with larger domain differences.

Table 4: Meta-learning methods with further adaptation steps. Further adaptation improves MatchingNet and MAML, but not for ProtoNet under the scenarios with little domain differences due to inconsistency between the meta-training and meta-testing stages. All statistics are for 5-shot accuracy with ResNet-18 backbone. The notation * indicates that only the new classifiers are updated. The notation # means the methods are updated for more gradient update steps.

Baseline Baseline++ ProtoNet
MatchingNet
MAML

Adapted
Yes* Yes*
No Yes* Relative Gain
No Yes* Relative Gain
No Yes# Relative Gain

CUB
82.85±0.55 83.58±0.54
87.42±0.48 87.15±0.50
-0.31%
82.75±0.58 84.39±0.57
1.98%
82.70±0.65 84.01±0.58
1.58%

mini-ImageNet
74.27±0.63 75.68±0.63
73.68±0.65 72.27±0.64
-1.91%
68.88±0.69 72.92±0.66
5.87%
65.72±0.77 70.67±0.70
7.53%

mini-ImageNet CUB
65.57±0.70 62.04±0.76
62.02±0.70 62.68±0.71
1.06%
53.07±0.74 57.99±0.77
9.27%
51.34±0.72 56.03±0.76
9.14%

sistency with the meta-training stage. The ProtoNet result shows that performance can degrade in scenarios with less domain difference. Thus, learning how to adapt in the meta-training stage is important. In summary, as domain differences are likely to exist in many real-world applications, we consider that learning to learn adaptation in the meta-training stage would be an important direction for future meta-learning works in few-shot classification.
5 CONCLUSIONS
In this paper, we have investigated the limits of the standard evaluation setting for few-shot classification. Through comparing methods on a common ground, our results show that the Baseline++ model is competitive to state of art under standard conditions, and the Baseline model achieves competitive performance with recent state-of-the-art meta-learning algorithms on both CUB and mini-ImageNet benchmark datasets when using a deeper feature backbone. Surprisingly, the Baseline compares favorably against all the evaluated meta-learning algorithms under a realistic scenario where there exists domain shift between the base and novel classes. By making our source code publicly available, we believe that community can benefit from the consistent comparative experiments and move forward to tackle the challenge of potential domain shifts in the context of few-shot learning.
9

Under review as a conference paper at ICLR 2019
REFERENCES
Antreas Antoniou, Amos Storkey, and Harrison Edwards. Data augmentation generative adversarial networks. In Proceedings of the International Conference on Learning Representations Workshops (ICLR Workshops), 2018. 1, 2
David L Davies and Donald W Bouldin. A cluster separation measure. IEEE Transactions on Pattern Analysis and Machine Intelligence, 1979. 12
Jia Deng, Wei Dong, Richard Socher, Li-Jia Li, Kai Li, and Li Fei-Fei. Imagenet: A large-scale hierarchical image database. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2009. 5
Chelsea Finn, Pieter Abbeel, and Sergey Levine. Model-agnostic meta-learning for fast adaptation of deep networks. In Proceedings of the International Conference on Machine Learning (ICML), 2017. 1, 2, 4, 5, 6, 7, 12
Yaroslav Ganin and Victor Lempitsky. Unsupervised domain adaptation by backpropagation. In Proceedings of the International Conference on Machine Learning (ICML), 2015. 3
Victor Garcia and Joan Bruna. Few-shot learning with graph neural networks. In Proceedings of the International Conference on Learning Representations (ICLR), 2018. 1, 3
Spyros Gidaris and Nikos Komodakis. Dynamic few-shot visual learning without forgetting. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2018. 1, 2, 3, 4
Bharath Hariharan and Ross Girshick. Low-shot visual recognition by shrinking and hallucinating features. In Proceedings of the IEEE International Conference on Computer Vision (ICCV), 2017. 1, 2
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recognition. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2016. 8
Nathan Hilliard, Lawrence Phillips, Scott Howland, Arte¨m Yankov, Courtney D Corley, and Nathan O Hodas. Few-shot learning with metric-agnostic conditional embeddings. arXiv preprint arXiv:1802.04376, 2018. 5
Yen-Chang Hsu, Zhaoyang Lv, and Zsolt Kira. Learning to cluster in order to transfer across domains and tasks. 2018. 3
Junlin Hu, Jiwen Lu, and Yap-Peng Tan. Deep transfer metric learning. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2015. 4
Gregory Koch, Richard Zemel, and Ruslan Salakhutdinov. Siamese neural networks for one-shot image recognition. In Proceedings of the International Conference on Machine Learning Workshops (ICML Workshops), 2015. 2
Thomas Mensink, Jakob Verbeek, Florent Perronnin, and Gabriela Csurka. Metric learning for large scale image classification: Generalizing to new classes at near-zero cost. In Proceedings of the European Conference on Computer Vision (ECCV). Springer, 2012. 4
George A Miller. Wordnet: a lexical database for english. Communications of the ACM, 1995. 8
Saeid Motiian, Quinn Jones, Seyed Iranmanesh, and Gianfranco Doretto. Few-shot adversarial domain adaptation. In Advances in Neural Information Processing Systems (NIPS), 2017. 3
Tsendsuren Munkhdalai and Hong Yu. Meta networks. In Proceedings of the International Conference on Machine Learning (ICML), 2017. 2
Sinno Jialin Pan, Qiang Yang, et al. A survey on transfer learning. IEEE Transactions on Knowledge and Data Engineering (TKDE), 2010. 3
10

Under review as a conference paper at ICLR 2019
Hang Qi, Matthew Brown, and David G Lowe. Low-shot learning with imprinted weights. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2018. 1, 2, 3, 4
Sachin Ravi and Hugo Larochelle. Optimization as a model for few-shot learning. In Proceedings of the International Conference on Learning Representations (ICLR), 2017. 1, 2, 5, 6, 12
Jake Snell, Kevin Swersky, and Richard Zemel. Prototypical networks for few-shot learning. In Advances in Neural Information Processing Systems (NIPS), 2017. 1, 3, 4, 5, 6, 7, 12
Flood Sung, Yongxin Yang, Li Zhang, Tao Xiang, Philip HS Torr, and Timothy M Hospedales. Learning to compare: Relation network for few-shot learning. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2018. 1, 3, 4, 5, 6, 7
Eric Tzeng, Judy Hoffman, Trevor Darrell, and Kate Saenko. Simultaneous deep transfer across domains and tasks. In Proceedings of the IEEE International Conference on Computer Vision (ICCV), 2015. 3
Oriol Vinyals, Charles Blundell, Tim Lillicrap, Daan Wierstra, et al. Matching networks for one shot learning. In Advances in Neural Information Processing Systems (NIPS), 2016. 1, 3, 4, 5, 7, 8, 12
Catherine Wah, Steve Branson, Peter Welinder, Pietro Perona, and Serge Belongie. The caltech-ucsd birds-200-2011 dataset. 2011. 5
Yu-Xiong Wang, Ross Girshick, Martial Hebert, and Bharath Hariharan. Low-shot learning from imaginary data. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2018. 1, 2, 12
11

Under review as a conference paper at ICLR 2019

APPENDIX

Different meta-learning works use different terminology in their work. We mark their difference as shown in appendix Table A1 to reduce confusion.
Table A1: Different terminology used in other works. Notation "-" indicates the term is the same as in this paper.

Our terms

Matchingnet Protonet Vinyals et al. Snell et al.

MAML Finn et al.

Meta-learm LSTM Imaginary Ravi & Larochelle Wang et al.

meta-training stage meta-testing stage

training test

training test

-

---

base class novel class

training set training set

test set

test set

task new task

meta-training set meta-testing set

-

support set query set

batch

-

sample

training dataset training data

-

test time sample

test dataset

test data

Also, as mentioned in Section 4.3, here we demonstrate that intra-class variation would be reduced when network depth gets deeper as in Figure A1. Here we use Davies-Bouldin index Davies & Bouldin (1979) to represent intra-class variation, which is a metric to evaluate the tightness in a cluster (or class, in our case). We could observe both intra-class variation in base and novel class feature would be reduced in a deeper backbone.

Davies-Bouldin index (Intra-class variation)

8 7 6 5 4 3 2
Conv-4

Baseline

Baseline++

Base class feature

Conv-6 Resnet-10 Resnet-18 Resnet-34

ProtoNet

MatchingNet

Novel class feature
7

6

5

4

3 Conv-4

Conv-6 Resnet-10 Resnet-18 Resnet-34

Figure A1: Intra-class variation decreases as backbone gets deeper. Here we use Davies-Bouldin index to represent intra-class variation, which is a metric to evaluate the tightness in a cluster (or class, in our case). The statistics are Davies-Bouldin index for all base and novel class feature (extracted by feature extractor learned after training or meta-training stage) for CUB dataset under different backbone.

12

Under review as a conference paper at ICLR 2019

Baseline 75%

Baseline++
CUB

MatchingNet 55%

ProtoNet

MAML

RelationNet

mini-ImageNet

1-shot

65%

50%

55%

45%

45%

40%

5-shot

90% 80% 70% 60%

80% 75% 70% 65% 60%

Figure A2: Few-shot classification accuracy vs. backbone depth. In the CUB dataset, gaps among different methods diminish as the backbone gets deeper. In mini-ImageNet 5-shot, some meta-learning methods are even beaten by Baseline with a deeper backbone.

Finally, we show larger version Figure 3 in Figure A2 and show detailed statistics in Table A2 for easier comparison.
Table A2: Detailed statistics in Figure 3. We put exact value here for reference.

CUB 1-shot
CUB 5-shot
mini-ImageNet 1-shot
mini-ImageNet 5-shot

Baseline Baseline++ MatchingNet ProtoNet
MAML RelationNet
Baseline Baseline++ MatchingNet ProtoNet
MAML RelationNet
Baseline Baseline++ MatchingNet ProtoNet
MAML RelationNet
Baseline Baseline++ MatchingNet ProtoNet
MAML RelationNet

Conv-4
47.12±0.74 60.53±0.83 61.16±0.89 51.31±0.91 55.92±0.95 62.45±0.98
64.16±0.71 79.34±0.61 72.86±0.70 70.77±0.69 72.09±0.76 76.11±0.69
42.11±0.71 48.24±0.75 48.14±0.78 44.42±0.84 46.47±0.82 49.31±0.85
62.53±0.69 66.43±0.63 63.48±0.66 64.24±0.72 62.71±0.71 66.60±0.69

Conv-6
55.77±0.86 66.00±0.89 67.16±0.97 66.07±0.97 65.91±0.97 63.11±0.94
73.07±0.71 82.02±0.55 77.08±0.66 78.14±0.67 76.31±0.74 77.81±0.66
45.82±0.74 48.29±0.72 50.47±0.86 50.37±0.83 50.96±0.92 51.84±0.88
66.42±0.67 68.09±0.69 63.19±0.70 67.33±0.67 66.09±0.71 64.55±0.70

Resnet-10
63.34±0.91 69.55±0.89 71.29±0.90 70.13±0.94 71.29±0.95 68.65±0.91
81.27±0.57 85.17±0.50 83.59±0.58 84.76±0.52 80.33±0.70 81.12±0.63
52.37±0.79 53.97±0.79 54.49±0.81 51.98±0.84 54.69±0.89 52.19±0.83
74.69±0.64 75.90±0.61 68.82±0.65 72.64±0.64 66.62±0.83 70.20±0.66

Resnet-18
65.51±0.87 67.02±0.90 72.36±0.90 71.88±0.91 69.96±1.01 67.59±1.02
82.85±0.55 83.58±0.54 83.64±0.60 87.42±0.48 82.70±0.65 82.75±0.58
51.75±0.80 51.87±0.77 52.91±0.88 54.16±0.82 49.61±0.92 52.48±0.86
74.27±0.63 75.68±0.63 68.88±0.69 73.68±0.65 65.72±0.77 69.83±0.68

Resnet-34
67.96±0.89 68.00±0.83 71.44±0.96 72.03±0.91 67.28±1.08 66.20±0.99
84.27±0.53 84.50±0.51 83.78±0.56 85.98±0.53 83.47±0.59 82.30±0.58
49.82±0.73 52.65±0.83 53.20±0.78 53.90±0.83 51.46±0.90 51.74±0.83
73.45±0.65 76.16±0.63 68.32±0.66 74.65±0.64 65.90±0.79 69.61±0.67

13

